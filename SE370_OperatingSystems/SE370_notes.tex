\documentclass{article} 
\newcommand\tab[1][0.5cm]{\hspace*{#1}}

\title{SOFTENG370 Notes 2017} 
\author{Theodore Oswandi} 

\usepackage[
	lmargin=2.5cm,
	rmargin=5cm,
	tmargin=1cm,
	bmargin=3cm,
	]{geometry}
\usepackage{enumitem}
\setlist{noitemsep}
\usepackage[none]{hyphenat}

\begin{document} \maketitle{} 

\section{Lecture 1}
	\subsection{Generics}
		\paragraph{\tab Operating System} The software that makes the computer usable. Using modern computers without an OS is "impossible"
			\\ \tab \textbf{Examples: }Windows, OSX, Linux, Unix, iOS, Android, etc...

		% \paragraph{\tab Things that are part of an OS?}
		% \begin{enumerate}
		% 	\item File System
		% 	\item Communication System
		% 	\item Process Manager
		% 	\item Security Manager
		% 	\item Memory Manager
		% 	\item Graphical User Interface
		% 	\item Backup System
		% 	\item Web Browser
		% 	\item Media Player
		% 	\item Compiler
		% 	\item Java/.Net environment.
		% \end{enumerate}

	\subsection{Approaches to Understanding}
		\paragraph{\tab Minimalist}
		\begin{itemize}
			\item mostly going to be using this one
			\item OS contains minimum amount of software to function
			\item archlike
		\end{itemize}

		\paragraph{\tab Maximalist}
		\begin{itemize}
			\item All software comes with standard OS release.
			\item Contains many utilities and programs.
			\item ubuntuish
		\end{itemize}

	\subsection{Usable vs Efficient}
		\begin{itemize}
			\item make sure you make OS suited for needs
			\item either specialised or more general purpose
			\item Think of who you expect to use the system
			\item If creating a realtime system with potentially thousands of operations in a short amount of time, have to consider efficiency
			\item Same with battery life if you expect the system to be used in a mobile setting.
		\end{itemize}

	\subsection{OS themes}
		\paragraph{\tab Manager Model}
			\begin{itemize}
				\item OS is colleciton of managers, ensuring proper use of devices.
				\item Managers are independent.
				\item look out for everything associated with computer 
				\item tie in with hardware. Current state of HW lets OS do more/less things
			\end{itemize}


		\paragraph{\tab Onion Model}
			\begin{itemize}
				\item Onions have layers (Abstractions)
				\item resources contained in lower layers. 
				\item Lower layers can't access higher level layers but other way around possible
				\item Very difficult to get these layers 'right'
				\item can use in terms of security. Very good idea
			\end{itemize}

		\paragraph{\tab Resource Allocator Model}
			\begin{itemize}
				\item similar to manager model
				\item emphasis on fairness and providing services
			\end{itemize}

		\paragraph{\tab Dustbin Model}
			\begin{itemize}
				\item contains middleware that not considered part of OS
				\item Sees OS as bits no-one wants to do
			\end{itemize}

		\paragraph{\tab Getting Work Done Model}
			\begin{itemize}
				\item Idea of it is we use computers to do something else.
				\item Goal for OS is to help be able to get it all done.
			\end{itemize}

	% Things we should know
	% 	Interrupt
	% 	Security&Protection
	% 	FileSystem
	% 	VirtualMemory
	% 	Processes&Threads

	\subsection{OS design}
		\subsubsection{Themes}
			\paragraph{\tab All in one}
			\begin{itemize}
				\item All OS components freely interact with each other
				\item MS-DOR and Early Linux
			\end{itemize}

			\paragraph{\tab Separate Layers (Onion Model)}
			\begin{itemize}
				\item Simplify verificiation and debugging
				\item Correct design difficult to get
			\end{itemize}

			\paragraph{\tab Modules}
			\begin{itemize}
				\item All in one with modules for some features
				\item Linux and Windows.
			\end{itemize}

			\paragraph{\tab Microkernels}
			\begin{itemize}
				\item Client/Server model
				\item make OS as small as possible

				\item \textbf{Exokernel} puts kernel outside. OS's job only need to authenticate people to use hardware.
			\end{itemize}

			\paragraph{\tab VMs}
			\begin{itemize}
				\item Java is an example of this
			\end{itemize}

	\subsubsection{MS-DOS}
		\begin{itemize}
			\item Written to provide the most functionality in the least amount of space
			\item not divided into modules
			\item Something exokernels trying to do. Make application program access hardware directly.
		\end{itemize}

	\subsubsection{Early Unix}
		\begin{itemize}
			\item UNIX OS in 2 parts. \textbf{Kernel} and \textbf{System Programs}
			\item Provides:
				\begin{itemize}
					\item File System
					\item CPU sheduling
					\item Memory management
					\item Other OS functions
				\end{itemize}
			\item Ken Thompson and Dennis Ritchie
			\item Make OS as simple as possible.
			\item Simple 2 letter commands.
			\item Ideas of pipelining and process communication
		\end{itemize}

	\subsubsection{THE Multiprogramming System}
		\begin{itemize}
			\item THE was the first to use the layered system
			\item Contains 6 layers:
				\begin{enumerate}
					\item[5] User programs
					\item[4] Input/Output buffering
					\item[3] Operator-Console device driver
					\item[2] Memory Management
					\item[1] CPU scheduling
					\item[0] Hardware
				\end{enumerate}
		\end{itemize}

	\subsubsection{WinNT and Client/Server}
		\begin{itemize}
			\item WinNT still being still run
				\begin{itemize}
					\item Win10 now has Windows Subsystem for Linux
				\end{itemize}
			\item NT provide env subsystem to run code written for differnt OS
			\item NT and successors are hybrid systems. Parts are layered but some merged to improve performance.
		\end{itemize}
		

\section{Lecture 2: History of OS}
	\begin{itemize}
		\item Started at mainframes.
		\begin{itemize}
			\item Early PDAs were similar to mainframes. Had no memory protection.
		\end{itemize}
		\item Then go to Minicomputers
		\item And then desktop
		\item And how handheld computers
	\end{itemize}

	\paragraph{\tab Each of these stages go through cycle of:}
	\begin{enumerate}
		\item No software
		\item Compulers
		\item Multiuser
		\item Networked
		\item Clustered
		\item Distributed Systems
		\item Multiprocessor \& Fault tolerant.
	\end{enumerate}

	\subsection{Total Control}
		\begin{itemize}
			\item Computers expensive in 50s. Data and programs were saved on paper tape.
			\item Programmers knew how the computer worked. They were very knowledgable about computers.
			\begin{itemize}
				\item Prepared program and data cards
				\item do setup
				\item control computer
				\item debug
			\end{itemize}
			\item Computers did 10,000s instructions per second, but were idle a lot of the time.
		\end{itemize}

	\subsection{Properties of old OS}
		\begin{itemize}
			\item \textbf{IO polling}, since no other programs running in background, therefore just waiting on input and able to just poll.
			\item No file system
			\item No memory management or security
			\item OS defined by decisions made by user.
			\item Single program at a time
		\end{itemize}

	\subsection{Progression: Operators \& Offlining}
		\paragraph{\tab Operators}
		\begin{itemize}
			\item Goal is to reduce the time CPU was doing nothing.
			\item Operators now just "use" the computer. No need for programmer.
			\begin{itemize}
				\item If something crashes, then just start the next program.
				\item Batch similar jobs together, maximise usage of computer.
			\end{itemize}
		\end{itemize}

		\paragraph{\tab Offlining}
		\begin{itemize}
			\item Form of parallelism in early computing.
			\item With Big Expensive Computer BEC, but they are just waiting for IO a lot of time. Therefore want to make IO as fast as possible.
			\item Use smaller computers to convert slower paper to faster magnetic tape. Then that magnetic tape is used as IO for the BEC
			\item This is the same for output. Have another smaller cheaper computer offload the output magnetic tape from BEC to a printer.
		\end{itemize}

		\paragraph{\tab Resident Monitor}
		\begin{itemize}
			\item Keep some code in memory.
			\item It did the work that some operators were doing.
			\begin{itemize}
				\item clearing memory
				\item reading start of new program that needs to be loaded.
				\item Can also do some of the IO routines.
			\end{itemize}
		\end{itemize}

		\paragraph{\tab Control Programs}
		Standardise the language to communicate with the Resident Monitor.
		\\ Had tags for things such as \$JOB (for signifying jobs), \$FTN (When fortran compiler needed), and \$END (signifying end of program)

		\paragraph{Conclusions from this}
		\begin{itemize}
			\item Memory management and file system still not present. Therefore still need to reset if anything bad happens.
			\item Security patchy at best
			\item Still need IO polling
			\item Standard IO routines for programmers
			\item 2 programs in memory, but one executed
			\item User interface was JCL (Job Control Language)
			\item Output of program can be input of another.
		\end{itemize}

	\subsection{Changes in Hardware}
		\begin{itemize}
			\item\textbf{Disk drives} provide faster IO.
			\item Processors that you can \textbf{interrupt} also means that there is no more reliance on polling.
			\item IO devices and CPU concurrent execution, and use local buffer.

		\paragraph{\tab SPOOLING (Simultaneous Peripheral Operation On-Line)}
			Meaning that when interrupt, contents of cards read to disk.
			Therefore current program interrupted.

	Multiprogramming
		Putting multiple programs on at once. Need more memory to do this.
		Now also need for scheduler to manage multiple users' program needs.
			Need to figure out how to manage stuff. Priority of jobs, how much time to allocate for these jobs, etc...
		No memory protection, so programs could overwrite other program's chunk of memory.
			Java is an example of somehting that doesn't give you direct access to memory in JVM.
			Memory Protection better done by hardware than having software impose limits. 

	2 Modes for memory protection
		User/Restricted Mode
		Kernel Mode (SU)

		Systems works differently in the 2 modes.

		Mode bit can be used to signify which mode its in.
			If do something in User mode, then go to Kernel mode and show exception before going back to User mode.

	Memory Protection
		Process gets area of memory that it can use
		Base and Limit register set for each process and how much memory it can have. 

	Batch systems
		REREAD SLIDES


\end{document}
