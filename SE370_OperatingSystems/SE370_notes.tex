\documentclass{article} 
\newcommand\tab[1][0.5cm]{\hspace*{#1}}

\title{SOFTENG370 Notes 2017} 
\author{Theodore Oswandi} 

\usepackage[
	lmargin=2.5cm,
	rmargin=5cm,
	tmargin=1cm,
	bmargin=3cm,
	]{geometry}
\usepackage{enumitem}
\setlist{noitemsep}
\usepackage[none]{hyphenat}

\begin{document} \maketitle{} 

\section{Lecture 1}
	\subsection{Generics}
		\paragraph{\tab Operating System} The software that makes the computer usable. Using modern computers without an OS is "impossible"
			\\ \tab \textbf{Examples: }Windows, OSX, Linux, Unix, iOS, Android, etc...

		% \paragraph{\tab Things that are part of an OS?}
		% \begin{enumerate}
		% 	\item File System
		% 	\item Communication System
		% 	\item Process Manager
		% 	\item Security Manager
		% 	\item Memory Manager
		% 	\item Graphical User Interface
		% 	\item Backup System
		% 	\item Web Browser
		% 	\item Media Player
		% 	\item Compiler
		% 	\item Java/.Net environment.
		% \end{enumerate}

	\subsection{Approaches to Understanding}
		\paragraph{\tab Minimalist}
		\begin{itemize}
			\item mostly going to be using this one
			\item OS contains minimum amount of software to function
			\item archlike
		\end{itemize}

		\paragraph{\tab Maximalist}
		\begin{itemize}
			\item All software comes with standard OS release.
			\item Contains many utilities and programs.
			\item ubuntuish
		\end{itemize}

	\subsection{Usable vs Efficient}
		\begin{itemize}
			\item make sure you make OS suited for needs
			\item either specialised or more general purpose
			\item Think of who you expect to use the system
			\item If creating a realtime system with potentially thousands of operations in a short amount of time, have to consider efficiency
			\item Same with battery life if you expect the system to be used in a mobile setting.
		\end{itemize}

	\subsection{OS themes}
		\paragraph{\tab Manager Model}
			\begin{itemize}
				\item OS is colleciton of managers, ensuring proper use of devices.
				\item Managers are independent.
				\item look out for everything associated with computer 
				\item tie in with hardware. Current state of HW lets OS do more/less things
			\end{itemize}


		\paragraph{\tab Onion Model}
			\begin{itemize}
				\item Onions have layers (Abstractions)
				\item resources contained in lower layers. 
				\item Lower layers can't access higher level layers but other way around possible
				\item Very difficult to get these layers 'right'
				\item can use in terms of security. Very good idea
			\end{itemize}

		\paragraph{\tab Resource Allocator Model}
			\begin{itemize}
				\item similar to manager model
				\item emphasis on fairness and providing services
			\end{itemize}

		\paragraph{\tab Dustbin Model}
			\begin{itemize}
				\item contains middleware that not considered part of OS
				\item Sees OS as bits no-one wants to do
			\end{itemize}

		\paragraph{\tab Getting Work Done Model}
			\begin{itemize}
				\item Idea of it is we use computers to do something else.
				\item Goal for OS is to help be able to get it all done.
			\end{itemize}

	% Things we should know
	% 	Interrupt
	% 	Security&Protection
	% 	FileSystem
	% 	VirtualMemory
	% 	Processes&Threads

	\subsection{OS design}
		\subsubsection{Themes}
			\paragraph{\tab All in one}
			\begin{itemize}
				\item All OS components freely interact with each other
				\item MS-DOR and Early Linux
			\end{itemize}

			\paragraph{\tab Separate Layers (Onion Model)}
			\begin{itemize}
				\item Simplify verificiation and debugging
				\item Correct design difficult to get
			\end{itemize}

			\paragraph{\tab Modules}
			\begin{itemize}
				\item All in one with modules for some features
				\item Linux and Windows.
			\end{itemize}

			\paragraph{\tab Microkernels}
			\begin{itemize}
				\item Client/Server model
				\item make OS as small as possible

				\item \textbf{Exokernel} puts kernel outside. OS's job only need to authenticate people to use hardware.
			\end{itemize}

			\paragraph{\tab VMs}
			\begin{itemize}
				\item Java is an example of this
			\end{itemize}

	\subsubsection{MS-DOS}
		\begin{itemize}
			\item Written to provide the most functionality in the least amount of space
			\item not divided into modules
			\item Something exokernels trying to do. Make application program access hardware directly.
		\end{itemize}

	\subsubsection{Early Unix}
		\begin{itemize}
			\item UNIX OS in 2 parts. \textbf{Kernel} and \textbf{System Programs}
			\item Provides:
				\begin{itemize}
					\item File System
					\item CPU sheduling
					\item Memory management
					\item Other OS functions
				\end{itemize}
			\item Ken Thompson and Dennis Ritchie
			\item Make OS as simple as possible.
			\item Simple 2 letter commands.
			\item Ideas of pipelining and process communication
		\end{itemize}

	\subsubsection{THE Multiprogramming System}
		\begin{itemize}
			\item THE was the first to use the layered system
			\item Contains 6 layers:
				\begin{enumerate}
					\item[5] User programs
					\item[4] Input/Output buffering
					\item[3] Operator-Console device driver
					\item[2] Memory Management
					\item[1] CPU scheduling
					\item[0] Hardware
				\end{enumerate}
		\end{itemize}

	\subsubsection{WinNT and Client/Server}
		\begin{itemize}
			\item WinNT still being still run
				\begin{itemize}
					\item Win10 now has Windows Subsystem for Linux
				\end{itemize}
			\item NT provide env subsystem to run code written for differnt OS
			\item NT and successors are hybrid systems. Parts are layered but some merged to improve performance.
		\end{itemize}
		

Lecture 2:
	History of OS
		Start at mainframes.
			Early PDAs were similar to mainframes. Had no memory protection.
		Then go to Minicomputers
		And then desktop
		And how handheld computers

		Go through cycle of:
			No software
			Compulers
			Multiuser
			Networked
			Distributed Systems
			Multiprocessor & Fault tolerant.

	Total Control
		Computers expensive in 50s
			Data & Programs saved on magnetic strip, or punch cards.
		Programmers knew how the computer worked. They were very knowledgable about computers.
		Computers did 10,000s instructions per second, but were idle a lot

		Old school computing
			IO polling, since no other programs running in bg, can just poll. CPU doing nothing.

		Progressing
			Goal is to reduce the time CPU was doing nothing.
			Operators now just "use" the computer. No need for programmer.
				If something crashes, then just start the next program.
				Batch similar jobs together, maximise usage of computer.

		Offlining
			With Big Expensive Computer BEC, but they are just waiting for IO a lot of time. Therefore want to make IO as fast as possible.
			Use smaller computers to convert slower paper to faster magnetic tape. Then that magnetic tape is used as IO for the BEC
			This is the same for output. Have another smaller cheaper computer offload the output magnetic tape from BEC to a printer.

		Resident Monitor
			Keep some code in memory.
			It did the work that some operators were doing.
				Things like clearing memory, and reading start of new program that needs to be loaded.
				Can also do some of the IO routines.

		Control Programs
			Standardise the language to communicate with the Resident Monitor.

	After all of this
		COPY RELEVANT FROM SLIDE

	Changes in hardware
		Disk drives
			Faster IO
		Processors that you can interrupt.
			No more reliance on polling.

	Change from Offlining to Onlining
		SPOOLING.	
			Meaning that when interrupt, contents of cards read to disk.
			Therefore current program interrupted.

	Multiprogramming
		Putting multiple programs on at once. Need more memory to do this.
		Now also need for scheduler to manage multiple users' program needs.
			Need to figure out how to manage stuff. Priority of jobs, how much time to allocate for these jobs, etc...
		No memory protection, so programs could overwrite other program's chunk of memory.
			Java is an example of somehting that doesn't give you direct access to memory in JVM.
			Memory Protection better done by hardware than having software impose limits. 

	2 Modes for memory protection
		User/Restricted Mode
		Kernel Mode (SU)

		Systems works differently in the 2 modes.

		Mode bit can be used to signify which mode its in.
			If do something in User mode, then go to Kernel mode and show exception before going back to User mode.

	Memory Protection
		Process gets area of memory that it can use
		Base and Limit register set for each process and how much memory it can have. 

	Batch systems
		REREAD SLIDES
		

\end{document}
