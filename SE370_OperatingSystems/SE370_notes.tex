\documentclass{article} 
\newcommand\tab[1][0.5cm]{\hspace*{#1}}

\title{SOFTENG370 Notes 2017} 
\author{Theodore Oswandi} 

\usepackage[
	lmargin=2.5cm,
	rmargin=5cm,
	tmargin=1cm,
	bmargin=3cm,
	]{geometry}
\usepackage{enumitem}
\setlist{noitemsep}
\usepackage[none]{hyphenat}

\begin{document} \maketitle{} 

\section{Lecture 1}
	\subsection{Generics}
		\paragraph{\tab Operating System} The software that makes the computer usable. Using modern computers without an OS is "impossible"
			\\ \tab \textbf{Examples: }Windows, OSX, Linux, Unix, iOS, Android, etc...

		% \paragraph{\tab Things that are part of an OS?}
		% \begin{enumerate}
		% 	\item File System
		% 	\item Communication System
		% 	\item Process Manager
		% 	\item Security Manager
		% 	\item Memory Manager
		% 	\item Graphical User Interface
		% 	\item Backup System
		% 	\item Web Browser
		% 	\item Media Player
		% 	\item Compiler
		% 	\item Java/.Net environment.
		% \end{enumerate}

	\subsection{Approaches to Understanding}
		\paragraph{\tab Minimalist}
		\begin{itemize}
			\item mostly going to be using this one
			\item OS contains minimum amount of software to function
			\item archlike
		\end{itemize}

		\paragraph{\tab Maximalist}
		\begin{itemize}
			\item All software comes with standard OS release.
			\item Contains many utilities and programs.
			\item ubuntuish
		\end{itemize}

	\subsection{Usable vs Efficient}
		\begin{itemize}
			\item make sure you make OS suited for needs
			\item either specialised or more general purpose
			\item Think of who you expect to use the system
			\item If creating a realtime system with potentially thousands of operations in a short amount of time, have to consider efficiency
			\item Same with battery life if you expect the system to be used in a mobile setting.
		\end{itemize}

	\subsection{OS themes}
		\paragraph{\tab Manager Model}
			\begin{itemize}
				\item OS is colleciton of managers, ensuring proper use of devices.
				\item Managers are independent.
				\item look out for everything associated with computer 
				\item tie in with hardware. Current state of HW lets OS do more/less things
			\end{itemize}


		\paragraph{\tab Onion Model}
			\begin{itemize}
				\item Onions have layers (Abstractions)
				\item resources contained in lower layers. 
				\item Lower layers can't access higher level layers but other way around possible
				\item Very difficult to get these layers 'right'
				\item can use in terms of security. Very good idea
			\end{itemize}

		\paragraph{\tab Resource Allocator Model}
			\begin{itemize}
				\item similar to manager model
				\item emphasis on fairness and providing services
			\end{itemize}

		\paragraph{\tab Dustbin Model}
			\begin{itemize}
				\item contains middleware that not considered part of OS
				\item Sees OS as bits no-one wants to do
			\end{itemize}

		\paragraph{\tab Getting Work Done Model}
			\begin{itemize}
				\item Idea of it is we use computers to do something else.
				\item Goal for OS is to help be able to get it all done.
			\end{itemize}

	% Things we should know
	% 	Interrupt
	% 	Security&Protection
	% 	FileSystem
	% 	VirtualMemory
	% 	Processes&Threads

	\subsection{OS design}
		\subsubsection{Themes}
			\paragraph{\tab All in one}
			\begin{itemize}
				\item All OS components freely interact with each other
				\item MS-DOR and Early Linux
			\end{itemize}

			\paragraph{\tab Separate Layers (Onion Model)}
			\begin{itemize}
				\item Simplify verificiation and debugging
				\item Correct design difficult to get
			\end{itemize}

			\paragraph{\tab Modules}
			\begin{itemize}
				\item All in one with modules for some features
				\item Linux and Windows.
			\end{itemize}

			\paragraph{\tab Microkernels}
			\begin{itemize}
				\item Client/Server model
				\item make OS as small as possible

				\item \textbf{Exokernel} puts kernel outside. OS's job only need to authenticate people to use hardware.
			\end{itemize}

			\paragraph{\tab VMs}
			\begin{itemize}
				\item Java is an example of this
			\end{itemize}

	\subsubsection{MS-DOS}
		\begin{itemize}
			\item Written to provide the most functionality in the least amount of space
			\item not divided into modules
			\item Something exokernels trying to do. Make application program access hardware directly.
		\end{itemize}

	\subsubsection{Early Unix}
		\begin{itemize}
			\item UNIX OS in 2 parts. \textbf{Kernel} and \textbf{System Programs}
			\item Provides:
				\begin{itemize}
					\item File System
					\item CPU sheduling
					\item Memory management
					\item Other OS functions
				\end{itemize}
			\item Ken Thompson and Dennis Ritchie
			\item Make OS as simple as possible.
			\item Simple 2 letter commands.
			\item Ideas of pipelining and process communication
		\end{itemize}

	\subsubsection{THE Multiprogramming System}
		\begin{itemize}
			\item THE was the first to use the layered system
			\item Contains 6 layers:
				\begin{enumerate}
					\item[5] User programs
					\item[4] Input/Output buffering
					\item[3] Operator-Console device driver
					\item[2] Memory Management
					\item[1] CPU scheduling
					\item[0] Hardware
				\end{enumerate}
		\end{itemize}

	\subsubsection{WinNT and Client/Server}
		\begin{itemize}
			\item WinNT still being still run
				\begin{itemize}
					\item Win10 now has Windows Subsystem for Linux
				\end{itemize}
			\item NT provide env subsystem to run code written for differnt OS
			\item NT and successors are hybrid systems. Parts are layered but some merged to improve performance.
		\end{itemize}
		

\section{Lecture 2: History of OS}
	\begin{itemize}
		\item Started at mainframes.
		\begin{itemize}
			\item Early PDAs were similar to mainframes. Had no memory protection.
		\end{itemize}
		\item Then go to Minicomputers
		\item And then desktop
		\item And how handheld computers
	\end{itemize}

	\paragraph{\tab Each of these stages go through cycle of:}
	\begin{enumerate}
		\item No software
		\item Compulers
		\item Multiuser
		\item Networked
		\item Clustered
		\item Distributed Systems
		\item Multiprocessor \& Fault tolerant.
	\end{enumerate}

	\subsection{Total Control}
		\begin{itemize}
			\item Computers expensive in 50s. Data and programs were saved on paper tape.
			\item Programmers knew how the computer worked. They were very knowledgable about computers.
			\begin{itemize}
				\item Prepared program and data cards
				\item do setup
				\item control computer
				\item debug
			\end{itemize}
			\item Computers did 10,000s instructions per second, but were idle a lot of the time.
		\end{itemize}

	\subsection{Properties of old OS}
		\begin{itemize}
			\item \textbf{IO polling}, since no other programs running in background, therefore just waiting on input and able to just poll.
			\item No file system
			\item No memory management or security
			\item OS defined by decisions made by user.
			\item Single program at a time
		\end{itemize}

	\subsection{Progression: Operators \& Offlining}
		\paragraph{\tab Operators}
		\begin{itemize}
			\item Goal is to reduce the time CPU was doing nothing.
			\item Operators now just "use" the computer. No need for programmer.
			\begin{itemize}
				\item If something crashes, then just start the next program.
				\item Batch similar jobs together, maximise usage of computer.
			\end{itemize}
		\end{itemize}

		\paragraph{\tab Offlining}
		\begin{itemize}
			\item Form of parallelism in early computing.
			\item With Big Expensive Computer BEC, but they are just waiting for IO a lot of time. Therefore want to make IO as fast as possible.
			\item Use smaller computers to convert slower paper to faster magnetic tape. Then that magnetic tape is used as IO for the BEC
			\item This is the same for output. Have another smaller cheaper computer offload the output magnetic tape from BEC to a printer.
		\end{itemize}

		\paragraph{\tab Resident Monitor}
		\begin{itemize}
			\item Keep some code in memory.
			\item It did the work that some operators were doing.
			\begin{itemize}
				\item clearing memory
				\item reading start of new program that needs to be loaded.
				\item Can also do some of the IO routines.
			\end{itemize}
		\end{itemize}

		\paragraph{\tab Control Programs}
		Standardise the language to communicate with the Resident Monitor.
		\\ Had tags for things such as \$JOB (for signifying jobs), \$FTN (When fortran compiler needed), and \$END (signifying end of program)

		\paragraph{Conclusions from this}
		\begin{itemize}
			\item Memory management and file system still not present. Therefore still need to reset if anything bad happens.
			\item Security patchy at best
			\item Still need IO polling
			\item Standard IO routines for programmers
			\item 2 programs in memory, but one executed
			\item User interface was JCL (Job Control Language)
			\item Output of program can be input of another.
		\end{itemize}

	\subsection{Changes in Hardware}
		\begin{itemize}
			\item\textbf{Disk drives} provide faster IO.
			\item Processors that you can \textbf{interrupt} also means that there is no more reliance on polling.
			\item IO devices and CPU concurrent execution, and use local buffer.
		\end{itemize}

		\paragraph{\tab SPOOLING (Simultaneous Peripheral Operation On-Line)}
			Meaning that when interrupt, contents of cards read to disk.
			Therefore current program interrupted.

	\subsection{Multiprogramming}
		\begin{itemize}
			\item Putting multiple programs on at once. Need more memory to do this.
			\item Now also need for scheduler to manage multiple users' program needs.
			\begin{itemize}
				\item Need to figure out how to manage stuff. Priority of jobs, how much time to allocate for these jobs, etc...
			\end{itemize}
			\item No memory protection, so programs could overwrite other program's chunk of memory.
			\begin{itemize}
				\item Java is an example of somehting that doesn't give you direct access to memory in JVM.
				\item Memory Protection better done by hardware than having software impose limits. 
			\end{itemize}
			\item \textbf{Requirements} Limited address range and Operating modes.
		\end{itemize}

		\paragraph{\tab Memory Protection Modes}
		\begin{enumerate}
			\item User/Restricted Mode
			\begin{itemize}
				\item Execution is done on behalf of the user.
				\item User should not have access to privileged instructions
			\end{itemize}
			\item Kernel Mode (SU)
			\begin{itemize}
				\item Execution done on behalf of the operating system
				\item Full access to all instructions.
			\end{itemize}
		\end{enumerate}
		A \textbf{mode bit} can be used to signify what mode a certain program is running in. If something in user mode tries to access memory it is not allocated to, it will go to Kernel mode and throw exception before going back to User mode.

		\paragraph{Why we need both} We need both because:
		\\\tab If modes existed with relevent instructions, but full memory access; there will still be a lack of memory protection, but also no privilege instruction protection. You can put whatever code you want anywhere.
		\\\tab If memory access limited but no modes or privilege access; then the user will be able to modify amount of memory available for programs.

		\paragraph{\tab Memory Protection}
		\begin{itemize}
			\item Process gets fixed area of memory that it can use
			\item If tries to access address out of that range then exception will be thrown.
			\item Base and Limit register set for each process and how much memory it can have. 
		\end{itemize}

	\subsection{Batch Systems}
		\paragraph{}Memory protection and Processor modes allow you to safely put multiple programs in memory.

		\paragraph{\tab Features}
		\begin{itemize}
			\item Jobs have their own protected memory
			\item Disks have file systems. Files linked to owners
			\item Automated Scheduling. Utilise hardware as much as possible, as operators are slow. Also allows fine tuning of how scheduler works.
			\item Computer consoles
		\end{itemize}

		Not much has changed from programmer's point of view.


\section{Lecture 3: History Continued}
	\subsection{Scheduling}
		\begin{itemize}
			\item Ams to maximise use of computing machinery OS knows
			\item Need to know details about device and file processes. What how much resources to allocate.
			\item Also has to take into account timing and output size.
		\end{itemize}

		SOMETHING ABOUT UNIVERSITY OF AUCKLAND SYSTEM

	\subsection{Power to the people}
		\begin{itemize}
			\item Due to hardware becoming cheaper, can have general public own personal computers
			\item Used to use teletypewriters, but used CRT TVs after a certain point. Editing text was difficult.
			\item At early 1970s, can code in similar style then you do now.
		\end{itemize}

	\subsection{Time Sharing System}
		\begin{itemize}
			\item People don't like waiting.
			\begin{itemize}
				\item 200ms+ noticable
				\item 5000ms+ unacceptible
			\end{itemize}
			\item Difficult for scheduler to figure out how to allocate resources. People use different computer differently with differing IO demands.
			\item Users expect command to run as soon as you press Enter.
			\item Don't want to have everything run at 100\%, otherwise it feels too slow.
			\item Security an issue for all of these people writing on terminal. Have to increase this and have authentication.
		\end{itemize}
		
		\paragraph{\tab Remnants of Batch Programming}
		\begin{itemize}
			\item Has way to run process at given time
			\item Terminal looked like cards until better graphics came
		\end{itemize}

	\subsection{1980s computers}
		\begin{itemize}
			\item Cycle starts again, started with Resident Monitor Systems.
			\item Simple single layer file systems
			\item No security, everything stored on disks. Didn't bother as it was aimed at individual users.
			\item Did spooling later, for printer output.
			\item Putting more than one program in memory, using similar system to resident monitor.
			\item Higher definition screens, pixel addressing for graphics.
			\item Cycle continues, things like time-sharing features and implementation of UNIX.
		\end{itemize}

		Xerox created GUI elements for Office use. Then Apple engineers used ideas to create their Mac.

		\paragraph{\tab Features}
		\begin{enumerate}
			\item Virtual memory
			\item Multiprogramming
			\item Complex file system
			\item Networking
			\item Multi-user
		\end{enumerate}

	\subsection{1980s Networking}
		\textbf{Security}, Transparency and Protocols/Standardisation create new problems.\\
		\textbf{Network OS:} File sharing, communication scheme, running independent to other machines on network.\\
		\textbf{Distributed OS:} Sharing processing power and resources of lots of computers to make it look like only single system.

	\subsection{Multiprocessor Systems}
		Heat is an issue, kind of a soft cap on processor frequency.
		Therefore can add more cores instead of trying to make each core faster.

		\paragraph{Tightly Coupled System} Processors sharing memory and clock. Communication through this shared memory. Most computers are now this.

		\paragraph{Parallel Systems} Mean increased throughput and cheaper way to increase performance. WIth increased reliability and rate of degradation.

		\paragraph{Symmetric Multiprocessing: }All core running same OS, most modern systems run this way
		
		\paragraph{Asymmetric Multiprocess}	Different cores allocated to different jobs/section. Used in very large systems.


	\subsection{Realtime System}
		Timing constraints very important.
		\paragraph{\tab Hard real-time}
		\begin{itemize}
			\item must run within time, or failure happens
			\item Has to be specifically designed to be hard realtime
			\item Nuclear plants, air traffic control
		\end{itemize}

		\paragraph{\tab Soft real-time}
		\begin{itemize}
			\item Doesn't matter too much, more lax.
			\item Most OS handle soft realtime
			\item Phone system, multimedia
		\end{itemize}

	\subsection{Pocket Computer \& Smartphones}
		\begin{itemize}
			\item Started as PDA/Pocket computers.
			\item Went through cycle again. Started as resident monitors.
			\begin{itemize}
				\item Due to hardware limitations, so have to start at the basic level again.
			\end{itemize}
			\item Battery life and power consumption very important factors.
		\end{itemize}

		\paragraph{PalmOS} Operating system that PalmPDAs ran on. \\
		Small memory with slow processor. \\
		Efficiency very important factor, to just get passable performance.

		\paragraph{Android} Popular operating system for current smartphones.\\
		Linux based, application programming in Java. \\
		Google trying to build their own kernel to replace Linux (Fuchsia)

		\paragraph{iOS} Operating systems that mobile Apple products run on. \\
		Based on OSX (Their desktop OS)\\
		virtual memory and paging for code but not data as writing to flash degrades it.



\section{Assignment Notes}
	\begin{itemize}
		\item Use standard UNIX symbols to control the threads

		\item setupstacktransfer()
		\begin{itemize} 
			\item \textbf{siguser1}	represents the user's signal. Let you send stuff to yourself
			\\ \tab similar to interrupt, but done in software and not hardware

			\item \textbf{sigaction} is a struct that holds information. Kind of like an object
			\\ \tab is global due to process having to be able to get to it at any time

			\item Has a separate, special stack for that singal handler to use.
			\item \textbf{man pages} are really important for this assignment. 
			\item If want to get all man pages relevant to signal then use $man -k signal$
		\end{itemize}

		\item Threads need their own stack
			\\ \tab Running independedntly of each other and calling their own functions so to guarantee proper functionng it is best for them to have their own stack

		\item \textbf{\&setupaction}
			address of instructions for the signal handler

		\item \textbf{thread1()}
		contains code that will be executed in the thread

		\item threadfuncts is array of names of functions that should be called for all threads
		If add more then you need to add to the array

		\item In task 2; 3 threads but 2 of them running the same logic from thread2()

		\item Information about thread structure found in littleThread.h

		\item static variables aren't allocated on the stack. And preserve value throughout multiple function calls

		\item MISSED UP TO LIKE 35min in

		\item \textbf{sigaltstack} lets you use that special alternate stack for different threads
		\\ \tab have malloc some memory and will use it
		\\ \tab When you call associateStack() when making new process you make a new alternate stack

		\item \textbf{kill(getpid(), SIGUSR1);}
		\\ \tab KILL is system call to get signals. Set it up but haven't associated it with anything it yet
		\\ \tab KILL sending pid of process you want to send it to. Send signal to yourself (try to kill yourself).
		% \\ \tab 

		\item make local copy of thread in fuction and set it to READY.

		\item C doesn't have exception handling. Therefore if error happens in a stack then need the ability to jump to part of memory to give error.
		\begin{itemize}
			\item \textbf{setjmp}: Take snapshot of where you are. Registers of processor (PC will contain this). Can also be used to "freeze" state of a given thread if need to be suspended.
			\item \textbf{longjmp}: Jump back to state where setjmp called. Can be used to "unfreeze" an already suspended thread to resume it. [Line34 in OSA.c]
			\item Copy stack information/register information and when jump back then recopy it back to "jump back to where you were"
			\item variable states preserved if stored on the stack
			\item if setjmp return 0 then returned directly, or nonzero if from longjmp. Will be used later for forking to create new processes, to check if from parent or child
		\end{itemize}

		\item \textbf{Switches} Pass it your current thread and the thread you want to go to.

		\item Only one thread running at a time, other ones will be READY due to only using a single processor.



		\item can get this assignment to work without understanding it
	\end{itemize}


\section{Lecture 4: Virtual Machines}
	./ used to signify that it isn't an internal command

	MISSED TO VIRTUALISATION

	Virtualisation
		if running on hardware then want to be as close to 90\% performance as possible. Preferably 95-98 but not always possible

	Design of IBM vm
		make each user feel like they have own cpu
		minidisk = lets user feel like they have access to whole drive
		problem is you don't want actual kernel mode to be accessable to all guests
			solution is each user has their own virtual kernel mode, but this kernel mode actually runs on the user level.
			Priviledged instructions actually needed to be passed down as not all things kernel does need that mode

	Hypervisor Types
		Allocating resources to VM 
			- like actual CPU cores
			- or chunks of memory allocated for it
		Can have "nested" vms

		Type 1
			Special purpose OS
			have support for bunch of tools to make using it easier

		Type 2
			Ones that you install yourself. (virtualbox, parallels)
			Run applications on host

	Problems
		trap and emulate couldn't be run on x86 up to a point.


	Hardware virtualisation x86
		Most OS only use level 0 (kernel mode) and level 3 (user mode)
		Problem with VM in real machine, then you need to keep track about process and registers. Have to keep track of this for all processes.
			Hardware system lets you change processor for one VM to another

		each VM page tables for their own processors
			used to have nested page table system. VMs create their own virtual page tables and some will exist in real memory

	Solutions
		Binary translation
			Look at instructions before execution, problem instructions get translated to be safer to be run in kernel mode

			These translations are similar
			Only translated code is run

	OS level virutalisation
		If lots of machines running same OS, then can use containers that make it seem like they are all separate. 
		Useful for servers
		Simpler than VMs as they are sharing same copy of OS

	More Styles
		paravirtualisation - XEN
			modify source code of OS you want to run
			increase efficiency to allow calls to be made straight to VMM instead of process

		Application Virtualisation
			WINE
			Want to run something made for an OS on another OS
			Makes the application think like its running on intended OS

		Windows Subsystem for Linux
			Not really virtual machines
			If app makes linux kernel call, kernel figures it out and sends it to subsystem
			Tied into kernel level, applicaiton doesn't really know about it. It just functions as normal and kernel does all of the work.

	C and OS implementations

Week 2 friday
	MISSED 10 MINUTES OF LECTURE

	Direct access to memory: address.c
		Whenever you run the program, the stack address space is different
		This is for security
			ASLR address space layout randomisation.
				Stack, heap and libraries put in different addresses.
				Helps add level of security

	Accessing Registers
		Can choose to store something in a register
		Use keyword 'register' prefacing variable type on initalise
		Can't get address of register, so if set to register OS may put it out of register into memory if you try get address of variable

	Volatile
		Another keyword prefacing variable type
		Don't do any clever tricks
			When you don't know if variable value will have changed due to non-local reason due to things like interrupt.

		Whenever you use this variable, you have to go back to memory and check its value again as it may have changed.

	Memory Management
		No memory management
		Static memory allocated at runtime, no malloc. But hard to get rid of them

	Dynamic memory
		Garbage collection doesn't inherently exist. As it is unpredictable

		Allocating stack space can be done by calling 'free'
		Free knows how much memory to free up since malloc uses a little bit more space just above for length of bit of stuff stored

	Inline assembly
		Example code is 32bit OS dependant
		Can put assembly language directly in C code

	Running commands from C program
		system() lets you put string of command you want to use

	Alternatives (languages for OS)
		C++
			similar to C but with object stuff too
			Windows has C kernel with some C++ and C\#
		Objective C
			MacOS written with ObjC, but trying to move to Swift
		Java
			Can't exclusively use java, need stuff with other stuff as well
		Assembly
			old school if you need even more fine tuning

More assignment stuff
	Part 1
		create a lot of threads, link them together (linked list)
		circular linked list (doubly) 
		keep going around cycle of threads until all finished executing.
		Only 2 threads given, but should be able to do with n threads
	Part 2
		Add thread.yield()
		This will call transition system like in part 1.
		Stop current thread (not finished) and pausing itself to allow another thread to run.
	Part 3
		Interrupt the thread with external source
		use set.itimer, send signal to processor to signify event happening. (timer has run out, every 20ms)
		Tells current thread to pause externally and start next thread.

Processes
	Instance of program execution
	Thing OS uses as construct to control work

Two parts
	Resources/Task/Job
		files open and using
		windows on screen
		restrictions on process
	Code that's running
		what process is actually doing
		these days have threads for multiple streams of instructions

Thread
	sequence of instructions executing without interruption
		this does happen, but not from thread's point of view. Thread can't tell if it has been paused or not
	Can run multiple threads but share resources

Typical uses
	split work accroess processors/cores
		thread for user response, another for some computation task
		GUI threads and process threads
	Server applications, have threads for clients.
		Server preallocates set of threads for handling requests

Thread implementations
	user level	
		OS sees one thread per process

		advantages
			work if os doesn't support threads
			easier to make, no system calls
			application specific control
			switching is easier (some have register files for threads)

	System level
		operating system knows about it
		controlled by system calls
		System knows about state of thread as well. Therefore will schedule based on their state

		advantages
			Threads treated separately
			If multiprocessor, then can schedule different threads on differnt processors
			thread blocking in kernel doesn't stop all thread on same process
				for example if doing read on file, usually code will wait for result and therefore block
				can allocate cpu to do something in the meantime in this case

	Jacketing
		Check "will I block" before doing something that may block
			check to see if data already exist in memory. If already there cna just get it without having to block. if have to get it, then let processor do something else while it tries to get data

	Best of Both worlds
		Solaris had both system and user level threads before ver9
			Uses one to one mapping of user level to kernel level threads.
			Mapping of single lightweight process to kernel threads. 
				lightweight processes
			If something on user level thread makes blocking call, other threads on that lightweight process gets to do its thing
				system makes its own kernel thread and new lightweight process to allow this to happen
		Windows 7 threads
			Since Win7 then have user mode scheduling. This also tries to get the best of both world
		Linux threads
			Used to not have threads, everything put on one thread
			Clone call
				makes a new process. Shares memory, open files and signal handlers
			Saw them as processes and not threads, so scheduled them
			Can't signal whole thread, therefore since cloned you aren't sending it to all of them and only the one you specify
			Killing threads dangerous, due to them sharing memory, then if killed then blocking may cause memory to be in inconsistent state as lock has not been released yet
			In POSIX, don't actually kill threads. You tell it to cancel itself instead, telling it to die at some point
				Threads are written in such as way that before it makes a blocking system call, it does some tidying so cancellations can happen
			Cloned threads can't block if other clone made blocking system call






Week 3 Wednesday
	More on threads and processes
	Part 3 assignment
		numthreads constant will be correct
			can initialise arrays with that size if you want

Lecture 6
	Process Control Blocks
		Things os should know about process
			BIG LIST GOES HERE
				process state turns out to be thread state
				priority used by scheduler
				owner - security considerations
				process generally on one processor (306 core moving cost)
				process group - proceessors working together
				memory and resource considerations
				see if process result can be piped to another process, or that it is waiting for result of this process

	UNIX process parts
		can be scattered as parts somewhere else
		process structure
			some of information of process held here

		user structure
			not instant access to this
			in user space
			some of information of process held here

		In UNIX, text = code

	WIndows NT
		split it up into lots of things in ANOTHER BIG LIST TO COPY YAY

		MISSED SLIDE 3 TO END OF LECTURE
			EMPHASIS ON FORKS

\section{Lecture 7}
	\subsection{Runnable}
		\begin{itemize}
			\item On one core, only one thread/process at the same time. (Exception SMT)
			\item Other processes/threads may be ready to run, or already running
		\end{itemize}
	\subsection{Multitasking}
		Pre-emptive Multitasking
		\begin{itemize}
			\item OS uses some kind of criteria to determine how large of a time slice that task
			\item The more you call yield and switch processes, the more time is wasted and less actual work is done by CPU
			\item \paragraph{Cognitive multitasking}
				
			Threads know that may have thread.yield() called on it and therefore are coded in a way such that when yield() is called, issues are less likely to occur
			
			Advantages
				\begin{itemize}
					\item Control
					\item Predictability
				\end{itemize}
			
			Disadvantages
				\begin{itemize}
					\item Critical Sessions
					\item Efficiency
				\end{itemize}
		\end{itemize}
		Co-operative Multitasking
		\begin{itemize}
			\item Two main ways to approach
			\begin{enumerate}
				\item Process yields right to run
				\item System stop process when system call made
			\end{enumerate}

			\item Doesn't mean task won't run and complete in one go.
			\item Old UNIX (before 2.6) didn't allow pre-emptive calls when making system calls
			\begin{itemize}
				\item pre-emptive multitasking always at user level
				\item hasn't always been preempntive at system level
				\item Actually used to be cooperative in the past
				\item Unix was written simpler in the past, expected it to be simple with blocking calls made.
			\end{itemize}
		\end{itemize}
		

	\subsection{Context Switch}
		\begin{itemize}
			\item Change from one process running to another on same processor, or to handle an interrupt
		\item Has to save the process state before this can occur
		\item Context changes as process executes
		\item Context contains:
		\begin{enumerate}
			\item Registers
			\item Memory (dynamic elements like call stack)
			\item Files \& Resources
			\item Caches
		\end{enumerate}

		\end{itemize}

	\subsection{Returning to Running}
		State Transition
		\begin{itemize}
			\item Store process properties so it can begin again where it left off
			\item Page table to be updated if changing processes
			\item Environment must be restored
			\item If changing threads on same process then may can just restore registers
			\item If system has multiple register sets then could thread change with 1 instruction
		\end{itemize}

	\subsection{OTHER STATES}
		\subsubsection{Waiting}
		

	Waiting
		To stop unnecessary resource consumption
		Status changed from runnng to waiting

	Suspended
		Different form of waiting

	Java
		Always had Threads from the start
		Threads have generally been user level
		Although Thread.suspend existed that froze thread on system level
			Thread.resume() to restore it
			Issue was some resources are tied to one process, and therefore gets a lock
			Therefore if frozen then other threads can't access it
		Threads.stop() kill thread and force it to release locks that it may have
			But may cause data to be left in inconsistent state

	Waiting in UNIX
		WCHAN can contain numbers, represents address in kernel
		Uses a queue to create a queue for processing
		Queue associated with hash value or kernel addresss

		HERE GOES SOME PROCESS OF HOW IT ALL WORKS

	Finishing
		Resouces used by process need to be accounted for
		Shared resources usage lowers due to process finishing
		Make sure tidying up is done, if not done already
			Don't rely on this, should do this yourself

		"When you log out, you want all your processes to finish too"
			Create a cascading effect, one process shutting down causes other ones associated with it to shut down too

	Reasons to Stop
		Normal Stop
			must call exit routine
			does all required tidyup

		Forced Stop
			Only want some processes to be able to kill specific processes.
				Parents can kill children
				Children can "generally" kill parents since same owner

	UNIX stopping
		Has 'zombie states'
			Process that is finished, until parent checks exit status
		This is a return state/value of a process
		Used so next process/processes can find out how child finishes and continue execution based on this result
		If parent is around and child finishes, child becomes a zombie

		If parent never calls wait
			if parent finishes then zombie is freed

	Another FSM

	Info from Linux Process Table
		NI = nice value
			can be positive a negative
			used to change priorities
				the lower the number, the higher the priority
				negative numbers are super priority
			Only SU can change nice values
			Normal users can only change nice values to positive values
		RSS = resident set size
			memory allocated to it
		TT = teletype
		TIME = how long process has been running for
		CMD = actual command that was executed

Lecture 8
	Scheduling Processes/Threads
		CPU burst time = time takes for thread running to have to wait for some reason
		Basically, the majority of threads stop after processing for not very long time
			therefore if we stop them frequently it doesn't make too much of a difference as they are probably waiting anyway
		




\end{document}
