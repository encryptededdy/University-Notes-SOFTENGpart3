\documentclass{article} 
\newcommand\tab[1][0.5cm]{\hspace*{#1}}

\title{SOFTENG370 Notes 2017} 
\author{Theodore Oswandi} 

\usepackage[
	lmargin=2.5cm,
	rmargin=5cm,
	tmargin=1cm,
	bmargin=3cm,
	]{geometry}
\usepackage{enumitem}
\setlist{noitemsep}
\usepackage[none]{hyphenat}

\begin{document} \maketitle{} 

\section{Lecture 1}
	\subsection{Generics}
		\paragraph{\tab Operating System} The software that makes the computer usable. Using modern computers without an OS is "impossible"
			\\ \tab \textbf{Examples: }Windows, OSX, Linux, Unix, iOS, Android, etc...

		% \paragraph{\tab Things that are part of an OS?}
		% \begin{enumerate}
		% 	\item File System
		% 	\item Communication System
		% 	\item Process Manager
		% 	\item Security Manager
		% 	\item Memory Manager
		% 	\item Graphical User Interface
		% 	\item Backup System
		% 	\item Web Browser
		% 	\item Media Player
		% 	\item Compiler
		% 	\item Java/.Net environment.
		% \end{enumerate}

	\subsection{Approaches to Understanding}
		\paragraph{\tab Minimalist}
		\begin{itemize}
			\item mostly going to be using this one
			\item OS contains minimum amount of software to function
			\item archlike
		\end{itemize}

		\paragraph{\tab Maximalist}
		\begin{itemize}
			\item All software comes with standard OS release.
			\item Contains many utilities and programs.
			\item ubuntuish
		\end{itemize}

	\subsection{Usable vs Efficient}
		\begin{itemize}
			\item make sure you make OS suited for needs
			\item either specialised or more general purpose
			\item Think of who you expect to use the system
			\item If creating a realtime system with potentially thousands of operations in a short amount of time, have to consider efficiency
			\item Same with battery life if you expect the system to be used in a mobile setting.
		\end{itemize}

	\subsection{OS themes}
		\paragraph{\tab Manager Model}
			\begin{itemize}
				\item OS is colleciton of managers, ensuring proper use of devices.
				\item Managers are independent.
				\item look out for everything associated with computer 
				\item tie in with hardware. Current state of HW lets OS do more/less things
			\end{itemize}


		\paragraph{\tab Onion Model}
			\begin{itemize}
				\item Onions have layers (Abstractions)
				\item resources contained in lower layers. 
				\item Lower layers can't access higher level layers but other way around possible
				\item Very difficult to get these layers 'right'
				\item can use in terms of security. Very good idea
			\end{itemize}

		\paragraph{\tab Resource Allocator Model}
			\begin{itemize}
				\item similar to manager model
				\item emphasis on fairness and providing services
			\end{itemize}

		\paragraph{\tab Dustbin Model}
			\begin{itemize}
				\item contains middleware that not considered part of OS
				\item Sees OS as bits no-one wants to do
			\end{itemize}

		\paragraph{\tab Getting Work Done Model}
			\begin{itemize}
				\item Idea of it is we use computers to do something else.
				\item Goal for OS is to help be able to get it all done.
			\end{itemize}

	% Things we should know
	% 	Interrupt
	% 	Security&Protection
	% 	FileSystem
	% 	VirtualMemory
	% 	Processes&Threads

	\subsection{OS design}
		\subsubsection{Themes}
			\paragraph{\tab All in one}
			\begin{itemize}
				\item All OS components freely interact with each other
				\item MS-DOR and Early Linux
			\end{itemize}

			\paragraph{\tab Separate Layers (Onion Model)}
			\begin{itemize}
				\item Simplify verificiation and debugging
				\item Correct design difficult to get
			\end{itemize}

			\paragraph{\tab Modules}
			\begin{itemize}
				\item All in one with modules for some features
				\item Linux and Windows.
			\end{itemize}

			\paragraph{\tab Microkernels}
			\begin{itemize}
				\item Client/Server model
				\item make OS as small as possible

				\item \textbf{Exokernel} puts kernel outside. OS's job only need to authenticate people to use hardware.
			\end{itemize}

			\paragraph{\tab VMs}
			\begin{itemize}
				\item Java is an example of this
			\end{itemize}

	\subsubsection{MS-DOS}
		\begin{itemize}
			\item Written to provide the most functionality in the least amount of space
			\item not divided into modules
			\item Something exokernels trying to do. Make application program access hardware directly.
		\end{itemize}

	\subsubsection{Early Unix}
		\begin{itemize}
			\item UNIX OS in 2 parts. \textbf{Kernel} and \textbf{System Programs}
			\item Provides:
				\begin{itemize}
					\item File System
					\item CPU sheduling
					\item Memory management
					\item Other OS functions
				\end{itemize}
			\item Ken Thompson and Dennis Ritchie
			\item Make OS as simple as possible.
			\item Simple 2 letter commands.
			\item Ideas of pipelining and process communication
		\end{itemize}

	\subsubsection{THE Multiprogramming System}
		\begin{itemize}
			\item THE was the first to use the layered system
			\item Contains 6 layers:
				\begin{enumerate}
					\item[5] User programs
					\item[4] Input/Output buffering
					\item[3] Operator-Console device driver
					\item[2] Memory Management
					\item[1] CPU scheduling
					\item[0] Hardware
				\end{enumerate}
		\end{itemize}

	\subsubsection{WinNT and Client/Server}
		\begin{itemize}
			\item WinNT still being still run
				\begin{itemize}
					\item Win10 now has Windows Subsystem for Linux
				\end{itemize}
			\item NT provide env subsystem to run code written for differnt OS
			\item NT and successors are hybrid systems. Parts are layered but some merged to improve performance.
		\end{itemize}
		

\section{Lecture 2: History of OS}
	\begin{itemize}
		\item Started at mainframes.
		\begin{itemize}
			\item Early PDAs were similar to mainframes. Had no memory protection.
		\end{itemize}
		\item Then go to Minicomputers
		\item And then desktop
		\item And how handheld computers
	\end{itemize}

	\paragraph{\tab Each of these stages go through cycle of:}
	\begin{enumerate}
		\item No software
		\item Compulers
		\item Multiuser
		\item Networked
		\item Clustered
		\item Distributed Systems
		\item Multiprocessor \& Fault tolerant.
	\end{enumerate}

	\subsection{Total Control}
		\begin{itemize}
			\item Computers expensive in 50s. Data and programs were saved on paper tape.
			\item Programmers knew how the computer worked. They were very knowledgable about computers.
			\begin{itemize}
				\item Prepared program and data cards
				\item do setup
				\item control computer
				\item debug
			\end{itemize}
			\item Computers did 10,000s instructions per second, but were idle a lot of the time.
		\end{itemize}

	\subsection{Properties of old OS}
		\begin{itemize}
			\item \textbf{IO polling}, since no other programs running in background, therefore just waiting on input and able to just poll.
			\item No file system
			\item No memory management or security
			\item OS defined by decisions made by user.
			\item Single program at a time
		\end{itemize}

	\subsection{Progression: Operators \& Offlining}
		\paragraph{\tab Operators}
		\begin{itemize}
			\item Goal is to reduce the time CPU was doing nothing.
			\item Operators now just "use" the computer. No need for programmer.
			\begin{itemize}
				\item If something crashes, then just start the next program.
				\item Batch similar jobs together, maximise usage of computer.
			\end{itemize}
		\end{itemize}

		\paragraph{\tab Offlining}
		\begin{itemize}
			\item Form of parallelism in early computing.
			\item With Big Expensive Computer BEC, but they are just waiting for IO a lot of time. Therefore want to make IO as fast as possible.
			\item Use smaller computers to convert slower paper to faster magnetic tape. Then that magnetic tape is used as IO for the BEC
			\item This is the same for output. Have another smaller cheaper computer offload the output magnetic tape from BEC to a printer.
		\end{itemize}

		\paragraph{\tab Resident Monitor}
		\begin{itemize}
			\item Keep some code in memory.
			\item It did the work that some operators were doing.
			\begin{itemize}
				\item clearing memory
				\item reading start of new program that needs to be loaded.
				\item Can also do some of the IO routines.
			\end{itemize}
		\end{itemize}

		\paragraph{\tab Control Programs}
		Standardise the language to communicate with the Resident Monitor.
		\\ Had tags for things such as \$JOB (for signifying jobs), \$FTN (When fortran compiler needed), and \$END (signifying end of program)

		\paragraph{Conclusions from this}
		\begin{itemize}
			\item Memory management and file system still not present. Therefore still need to reset if anything bad happens.
			\item Security patchy at best
			\item Still need IO polling
			\item Standard IO routines for programmers
			\item 2 programs in memory, but one executed
			\item User interface was JCL (Job Control Language)
			\item Output of program can be input of another.
		\end{itemize}

	\subsection{Changes in Hardware}
		\begin{itemize}
			\item\textbf{Disk drives} provide faster IO.
			\item Processors that you can \textbf{interrupt} also means that there is no more reliance on polling.
			\item IO devices and CPU concurrent execution, and use local buffer.
		\end{itemize}

		\paragraph{\tab SPOOLING (Simultaneous Peripheral Operation On-Line)}
			Meaning that when interrupt, contents of cards read to disk.
			Therefore current program interrupted.

	\subsection{Multiprogramming}
		\begin{itemize}
			\item Putting multiple programs on at once. Need more memory to do this.
			\item Now also need for scheduler to manage multiple users' program needs.
			\begin{itemize}
				\item Need to figure out how to manage stuff. Priority of jobs, how much time to allocate for these jobs, etc...
			\end{itemize}
			\item No memory protection, so programs could overwrite other program's chunk of memory.
			\begin{itemize}
				\item Java is an example of somehting that doesn't give you direct access to memory in JVM.
				\item Memory Protection better done by hardware than having software impose limits. 
			\end{itemize}
			\item \textbf{Requirements} Limited address range and Operating modes.
		\end{itemize}

		\paragraph{\tab Memory Protection Modes}
		\begin{enumerate}
			\item User/Restricted Mode
			\begin{itemize}
				\item Execution is done on behalf of the user.
				\item User should not have access to privileged instructions
			\end{itemize}
			\item Kernel Mode (SU)
			\begin{itemize}
				\item Execution done on behalf of the operating system
				\item Full access to all instructions.
			\end{itemize}
		\end{enumerate}
		A \textbf{mode bit} can be used to signify what mode a certain program is running in. If something in user mode tries to access memory it is not allocated to, it will go to Kernel mode and throw exception before going back to User mode.

		\paragraph{Why we need both} We need both because:
		\\\tab If modes existed with relevent instructions, but full memory access; there will still be a lack of memory protection, but also no privilege instruction protection. You can put whatever code you want anywhere.
		\\\tab If memory access limited but no modes or privilege access; then the user will be able to modify amount of memory available for programs.

		\paragraph{\tab Memory Protection}
		\begin{itemize}
			\item Process gets fixed area of memory that it can use
			\item If tries to access address out of that range then exception will be thrown.
			\item Base and Limit register set for each process and how much memory it can have. 
		\end{itemize}

	\subsection{Batch Systems}
		\paragraph{}Memory protection and Processor modes allow you to safely put multiple programs in memory.

		\paragraph{\tab Features}
		\begin{itemize}
			\item Jobs have their own protected memory
			\item Disks have file systems. Files linked to owners
			\item Automated Scheduling. Utilise hardware as much as possible, as operators are slow. Also allows fine tuning of how scheduler works.
			\item Computer consoles
		\end{itemize}

		Not much has changed from programmer's point of view.


\section{Lecture 3: History Continued}
	\subsection{Scheduling}
		\begin{itemize}
			\item Ams to maximise use of computing machinery OS knows
			\item Need to know details about device and file processes. What how much resources to allocate.
			\item Also has to take into account timing and output size.
		\end{itemize}

		SOMETHING ABOUT UNIVERSITY OF AUCKLAND SYSTEM

	\subsection{Power to the people}
		\begin{itemize}
			\item Due to hardware becoming cheaper, can have general public own personal computers
			\item Used to use teletypewriters, but used CRT TVs after a certain point. Editing text was difficult.
			\item At early 1970s, can code in similar style then you do now.
		\end{itemize}

	\subsection{Time Sharing System}
		\begin{itemize}
			\item People don't like waiting.
			\begin{itemize}
				\item 200ms+ noticable
				\item 5000ms+ unacceptible
			\end{itemize}
			\item Difficult for scheduler to figure out how to allocate resources. People use different computer differently with differing IO demands.
			\item Users expect command to run as soon as you press Enter.
			\item Don't want to have everything run at 100\%, otherwise it feels too slow.
			\item Security an issue for all of these people writing on terminal. Have to increase this and have authentication.
		\end{itemize}
		
		\paragraph{\tab Remnants of Batch Programming}
		\begin{itemize}
			\item Has way to run process at given time
			\item Terminal looked like cards until better graphics came
		\end{itemize}

	\subsection{1980s computers}
		\begin{itemize}
			\item Cycle starts again, started with Resident Monitor Systems.
			\item Simple single layer file systems
			\item No security, everything stored on disks. Didn't bother as it was aimed at individual users.
			\item Did spooling later, for printer output.
			\item Putting more than one program in memory, using similar system to resident monitor.
			\item Higher definition screens, pixel addressing for graphics.
			\item Cycle continues, things like time-sharing features and implementation of UNIX.
		\end{itemize}

		Xerox created GUI elements for Office use. Then Apple engineers used ideas to create their Mac.

		\paragraph{\tab Features}
		\begin{enumerate}
			\item Virtual memory
			\item Multiprogramming
			\item Complex file system
			\item Networking
			\item Multi-user
		\end{enumerate}

	\subsection{1980s Networking}
		\textbf{Security}, Transparency and Protocols/Standardisation create new problems.\\
		\textbf{Network OS:} File sharing, communication scheme, running independent to other machines on network.\\
		\textbf{Distributed OS:} Sharing processing power and resources of lots of computers to make it look like only single system.

	\subsection{Multiprocessor Systems}
		Heat is an issue, kind of a soft cap on processor frequency.
		Therefore can add more cores instead of trying to make each core faster.

		\paragraph{Tightly Coupled System} Processors sharing memory and clock. Communication through this shared memory. Most computers are now this.

		\paragraph{Parallel Systems} Mean increased throughput and cheaper way to increase performance. WIth increased reliability and rate of degradation.

		\paragraph{Symmetric Multiprocessing: }All core running same OS, most modern systems run this way
		
		\paragraph{Asymmetric Multiprocess}	Different cores allocated to different jobs/section. Used in very large systems.


	\subsection{Realtime System}
		Timing constraints very important.
		\paragraph{\tab Hard real-time}
		\begin{itemize}
			\item must run within time, or failure happens
			\item Has to be specifically designed to be hard realtime
			\item Nuclear plants, air traffic control
		\end{itemize}

		\paragraph{\tab Soft real-time}
		\begin{itemize}
			\item Doesn't matter too much, more lax.
			\item Most OS handle soft realtime
			\item Phone system, multimedia
		\end{itemize}

	\subsection{Pocket Computer \& Smartphones}
		Started as PDA/Pocket computers.
		Went through cycle again. Started as resident monitors.
			Due to hardware limitations, so have to start cycle again.
		Battery life and power consumption very important factors.

		PalmOS
			Small memory with slow processor. Efficiency very important factor (to just get passable performance)

		Android
			Linux based, application programming in Java.

		iOS
			OSX based, with virtual memory and paging for code but not data. Writing to flash degrades it.


\end{document}
