Week4_JimTLDR

Lectures
	1	Design Principles
	2	Physical Design

Lecture 1: Design Principles
	Learning Objectives:
		- apply design principles to UI design
		- characterise principles for efficacy
		- conceptualise priciples in terms of interaction framework

		Efficacy: ability to produce desired result based on efficiency and effectiveness

	1.1: Principles of Interaction Design
		- make elegant solution to compled problem
		- how to make powerful and aesthetically pleasing design
		- clear, minimal, to the point and powerful
		- complicated is also good
		- there are always tradeoffs

		- Design principles to guide design decisions
		- don't prescribe outcomes, but point in right direction

	1.2: Framework for Design Principles
		Functionality -> Presentation Filter | Usability -> Usefulness
		| = compresensibility barrier
		Usability & Usefulness is Efficacy

		Functionality: systems have enough functionality for certain task
		Presentation Filter: functionality must be accessible through this (is the interface)
		Comprehensibility Barrier: user needs to understand how to access functionality
		Learnability: comprehensible and learnable direct correlation
		Usability: can user do task
		Usefulness: can user do task enjoyably

	1.3: Comprehensibility
		- if easy to comprehend will be efficient and effecitve
		- affordance and metaphor important
		- don't want to confuse user with use of metaphors

	1.4: Learnability
		- if can't understand, can't learn

	1.5: Efficacy
		- efficiency + effectiveness

		Effectiveness: has right functionality
		Efficiency: user can do task fast and easily

		1.5.1: Effectiveness
			Utility:
				- what user can do with system

			Safety:
				- the safer, the less risky it is
				- recovery hard to implement but important

			Flexbility:
				- can be used in multiple environments.
				- address diverse needs
				- customisation will improve this

			Stability:
				- is system robust
				- consistent functioning is good

		1.5.2: Efficiency/Usability
			Simplicity:
				- easier to learn, easier to remember
				- simplest is best (Ockham's Razor)
				- 80/20: 80% of usage is on 20% of functionality
				- Satisficing: find balance between satisfying requirements and good enough to fit with design

				Progressive Disclosure:
				- only show user basics
				- use of "more" button

				Constraints:
				- grey out buttons they shouldn't be able to use anyway
				- limiting actions

				Conventions:
				- exploit learned behaviours to influence

				Symbols:
				- define meaning to little images (affordance and metaphor)


			Memorability:
				- easy to learn and use

				parameters:
				- location
				- logical grouping
				- conventions
				- redundancy

			Predictability:
				- user ability to determine action ahead of time
				- consistency very imporatnt
				- reinforce association

				Generalisability: use of previous experience
				COnventions: use of intuition
				Familiarity: names help locate things more easily
				Location: use of important parts of screen (top left)
				Modes: change how objects function (caps lock)

			Visibility:
				- make user aware of functionality and components

				Feedback (GOOD): let user know feedback about actions
				Overload (BAD): don't show too much

				Recognition/Recall
				- we're better at recognising things than recalling stuff.

				Orientation: make user sure of where they are in the design

	1.6: Affordance & Metaphor
		1.6.1: Affordance
			- particular items suggest how they should be used
			- ensure that certain functionality is put in component that makes sense for use. Don't put title in text box
			- rely on user knowing the link between real world concept

			[Buttons and clicking]

		1.6.2: Metaphor
			- use physical world concepts and use on computers
			- most icons are metaphors
			- rely on users knowing link between real world concept
			- make recognition faster if well implemented

			[Windows, Documents, Folders]



Lecture 2: Physical Design
	Learning Objectives:
		- see value or prototyping
		- know different options available for certain problems
		- make useful prototypes to elicit user feedback

	2.1: Low Fidelity Prototype
		2.1.1: General
			- design process determine looks, components and UI layout
			- want lots of feedback early
			- easier to critisize simple paper prototype

			Neilsen types:
				Horizontal: 
				- lots of functionality but none in depth
				- used when need to see overall picture

				Vertical: 
				- Not much functionality but ones that exist are implemented thoroughly
				- used when one feature very important

			Criteria:
				- Easy and inexpensive to make
				- easily changed
				- complete enough for specific functionality

		2.1.2: Creation
			- pen and paper
			- nothing too neat, meant to look rough
			- post its let you change things easily and make various UI elements
			- use real objects to represent various elements (dial)

		2.1.3: Use
			- Wizard of Oz prototyping very important
			- one person computer and other as user
			- can modify on the fly according to user feedback

		2.1.4: Advantages & Disadvantages
			Advantages:
				- early and often
				- inexpensive
				- visual representation

			Disadvantages:
				- not interactive
				- no response timings
				- no colour or font choice considerations

		2.1.5: Tidying up prototype
			- the nicer the more people enjoy using it
			- but people less critical when given formal prototype and therefore less changes made.

	2.2: Electronic Prototype
		- still quick and easy, but with interaction too
		- Powerpoint can be used for logical sequence of screens
			- can add buttons for various functionality
		- Balsamiq example of one that is used

		- Make dummy data, don't leave blank
		- Ipsum Lorem if needed

	2.3: Storyboard
		- comic strip of scenario
		- visioning use of system

	2.4: Whiteboard prototype
		- good for early design
		- collaborative, good for brainstorm and walkthrough

	2.5: Cognitive Walkthrough
		- evalation team walk through scenario
		- focus on problems and not solutions
		- think like how they would use program to identify good/bad things

	2.6: Iteration
		- go through processes multiple time
		- discover ways to change/improve things
		- change things like scenarios, requirements, etc...
		