\documentclass{article} 
\newcommand\tab[1][0.5cm]{\hspace*{#1}}

\title{COMPSYS304 Notes 2017} 
\author{Theodore Oswandi} 

\usepackage[
	lmargin=2.5cm,
	rmargin=5cm,
	tmargin=1cm,
	bmargin=3cm,
	]{geometry}
\usepackage{enumitem}
\setlist{noitemsep}
\usepackage[none]{hyphenat}

\begin{document} \maketitle{} 

\section{Lecture 1}
	\subsection{Improvements}
		\begin{itemize}
			\item Semiconductor technology and computer architecture has increased lots in last 50 years
			\item Performance, which has also increased can be measured from standardised benchmarks
			\item Clock rate/frequency has also increased considerably in this time.
		\end{itemize}

	\subsection{Computer Architecture}
		\paragraph{\tab ISA} Boundary between hardware and software
		\paragraph{\tab Oragnisation} high level computer design aspects
		\paragraph{\tab Hardware} detailed logic and circuit design

		\paragraph{\tab Note:} You want to separate your instruction set from implementation

	\subsection{Memory Organisation}
		\begin{itemize}
			\item See memory as single 1D array
			\item Address is index of this array, points to byte of memory.
			\item Memory Access Time: time to read data to/from memory \\ 
			\item Memory Speed != Processor speed.
			\item Fast memory is very expensive. Heirarchy used to maintain fluid functionality and keep things cheap.
		\end{itemize}

		\paragraph{\tab Processor Registers}
		\begin{itemize}
			\item Smallest and fastest memory for CPU
			\item about 32-64 of them.
			\item Each are 32/64bits in size.
			\item Nanosecond access time
		\end{itemize}

		\paragraph{\tab Cache Memory}
		\begin{itemize}
			\item Slower than register
			\item 8-256k
			\item Few nanoseconds access time
			\item Levels to this as well. L1, L2, L3 cache used in multiprocessor systems.
		\end{itemize}

		\paragraph{\tab Main Memory}
		\begin{itemize}
			\item Slower than cache
			\item Megabytes to gigabytes of size.
			\item Tens of nanoseconds lookup time.
		\end{itemize}

	\subsection{Instruction Set Architecture (ISA)}
		\paragraph{\tab ISA} is interface between hardware and low level software.
		\paragraph{\tab Modern ISA} include 80x86, MIPS, ARM

		\subsubsection{Using Fixed ISAs}
			\paragraph{} Uses old instruction set (1970s), also used with extensions to enable newer technologies such as internet, etc...

			\paragraph{\tab Advantages}
			\begin{itemize}
				\item AMD/Intel both have same ISA but different implementation.
			\end{itemize}

			\paragraph{\tab Disadvantages}
				\begin{itemize}
					\item power consumption is higher than things like iPad which use different ISA and consume a lot less power
					\item Also prevent some new innovation since it is so widely used in today's world.
				\end{itemize}


		\subsubsection{ISA Design}
			\paragraph{\tab Need to ask:}
			\begin{itemize}
				\item What operations do the CPU need to do?
				\item How to provide data for given operations?
				\item How to store results of these calculations?
			\end{itemize}

			\paragraph{\tab Need to define:}
			\begin{itemize}
				\item Instruction Format and Encoding
				\item Data types and their sizes
				\item Location of operands and where to store results
			\end{itemize}

		\paragraph{\tab Operands and Opcodes} To carry out these calculations, an \textbf{opcode} must be defined to define these calculations. Upon these opcodes, zero to three \textbf{operands} are used for data inputs and result outputs.

	\subsection{Architecture Types}
		\subsubsection{Stack Base Architecture}
			\begin{itemize}
				\item Top of stack will contain result of operation.
				\item If receive ADD then processor knows next 2 inputs contain 2 numbers that need to be added.
				\item PUSH add something to top of stack.
				\item POP use value in top of stack.
				\item JVM designed to use Stack based architecture.
				\item ADD function has no operators. Operates on last 2 loaded values.
			\end{itemize}

		\subsubsection{Accumulator Based Archictecture.}
			\begin{itemize}
				\item Using inputs from memory.
				\item Not used anymore today. Used in 1970s
				\item ADD function takes one operator, $mem_address$ which contains the value to add to above loaded value.
			\end{itemize}

		\subsubsection{Register Memory Architecture}
			\begin{itemize}
				\item Currently used today as x86
				\item Uses register for input as well as access values from memory.
				\item ADD function contains 3 operator.
					\begin{enumerate}
						\item \textbf{Rd} Destination Register
						\item \textbf{Rs} Source Register
						\item \textbf{mem\_address} Address of value to add from memory
					\end{enumerate}
			\end{itemize}

		\subsubsection{Register-Register Architecture}
			\begin{itemize}
				\item Operands from register.
				\item LOAD and STORE from memory too.
				\item Need to specify destination register for output.
				\item ADD function has 3 operators.
					\begin{enumerate}
						\item \textbf{Rd} Destination Register
						\item \textbf{Rs} Source Register 
						\item \textbf{Rt} Register containing other value you want to add
					\end{enumerate}
			\end{itemize}

		\subsubsection{Examples}
		Example is $A(1000) + B(2000) = C(3000)$ in the 4 types of architectures
		
		\paragraph{Stack Based Architecture\\}
				PUSH 1000 \\ \tab
				PUSH 2000 \\ \tab
				ADD \\ \tab
				POP 3000

		\paragraph{Accumulator Based\\}
				LOAD 1000 \\ \tab
				ADD 2000 \\ \tab
				STORE 3000

		\paragraph{Register Memory\\}
				LOAD R2, 1000 \\ \tab
				ADD R1, R2, 2000 \\ \tab
				STORE R1, 3000

		\paragraph{Register Register\\}
				LOAD R2, 1000 \\ \tab
				LOAD R3, 2000 \\ \tab
				ADD R1, R2, R3 \\ \tab
				STORE R1, 3000


		ISA CLASSES
			RISC
				Reduced

			CISC
				Complex

			EPIC


		

\end{document}
