\documentclass{article} 
\newcommand\tab[1][0.5cm]{\hspace*{#1}}

\title{COMPSYS304 Notes 2017} 
\author{Theodore Oswandi} 

\usepackage[
	lmargin=2.5cm,
	rmargin=5cm,
	tmargin=1cm,
	bmargin=3cm,
	]{geometry}
\usepackage{enumitem}
\setlist{noitemsep}
\usepackage[none]{hyphenat}

\begin{document} \maketitle{} 

\section{Lecture 1 \& 2}
	\subsection{Improvements}
		\begin{itemize}
			\item Semiconductor technology and computer architecture has increased lots in last 50 years
			\item Performance, which has also increased can be measured from standardised benchmarks
			\item Clock rate/frequency has also increased considerably in this time.
		\end{itemize}

	\subsection{Computer Architecture}
		\textbf{\tab ISA:} Boundary between hardware and software\\
		\textbf{\tab Oragnisation:} high level computer design aspects\\
		\textbf{\tab Hardware:} detailed logic and circuit design
		\\ \\
		\textbf{\tab Note:} You want to separate your instruction set from implementation

	\subsection{Memory Organisation}
		\begin{itemize}
			\item See memory as single 1D array
			\item Address is index of this array, points to byte of memory.
			\item Memory Access Time: time to read data to/from memory \\ 
			\item Memory Speed != Processor speed.
			\item Fast memory is very expensive. Heirarchy used to maintain fluid functionality and keep things cheap.
		\end{itemize}

		\paragraph{\tab Processor Registers}
		\begin{itemize}
			\item Smallest and fastest memory for CPU
			\item about 32-64 of them.
			\item Each are 32/64bits in size.
			\item Nanosecond access time
		\end{itemize}

		\paragraph{\tab Cache Memory}
		\begin{itemize}
			\item Slower than register
			\item 8-256k
			\item Few nanoseconds access time
			\item Levels to this as well. L1, L2, L3 cache used in multiprocessor systems.
		\end{itemize}

		\paragraph{\tab Main Memory}
		\begin{itemize}
			\item Slower than cache
			\item Megabytes to gigabytes of size.
			\item Tens of nanoseconds lookup time.
		\end{itemize}

	\subsection{Instruction Set Architecture (ISA)}
		\paragraph{\tab ISA} is interface between hardware and low level software.
		\paragraph{\tab Modern ISA} include 80x86, MIPS, ARM

		\subsubsection{Using Fixed ISAs}
			\paragraph{} Uses old instruction set (1970s), also used with extensions to enable newer technologies such as internet, etc...

			\paragraph{\tab Advantages}
			\begin{itemize}
				\item AMD/Intel both have same ISA but different implementation.
			\end{itemize}

			\paragraph{\tab Disadvantages}
				\begin{itemize}
					\item power consumption is higher than things like iPad which use different ISA and consume a lot less power
					\item Also prevent some new innovation since it is so widely used in today's world.
				\end{itemize}


		\subsubsection{ISA Design}
			\paragraph{\tab Need to ask:}
			\begin{itemize}
				\item What operations do the CPU need to do?
				\item How to provide data for given operations?
				\item How to store results of these calculations?
			\end{itemize}

			\paragraph{\tab Need to define:}
			\begin{itemize}
				\item Instruction Format and Encoding
				\item Data types and their sizes
				\item Location of operands and where to store results
			\end{itemize}

		\paragraph{\tab Operands and Opcodes} To carry out these calculations, an \textbf{opcode} must be defined to define these calculations. Upon these opcodes, zero to three \textbf{operands} are used for data inputs and result outputs.

	\subsection{Architecture Types}
		\subsubsection{Stack Base Architecture}
			\begin{itemize}
				\item Top of stack will contain result of operation.
				\item If receive ADD then processor knows next 2 inputs contain 2 numbers that need to be added.
				\item PUSH add something to top of stack.
				\item POP use value in top of stack.
				\item JVM designed to use Stack based architecture.
				\item ADD function has no operators. Operates on last 2 loaded values.
			\end{itemize}

		\subsubsection{Accumulator Based Archictecture.}
			\begin{itemize}
				\item Using inputs from memory.
				\item Not used anymore today. Used in 1970s
				\item ADD function takes one operator, $mem_address$ which contains the value to add to above loaded value.
			\end{itemize}

		\subsubsection{Register Memory Architecture}
			\begin{itemize}
				\item Currently used today as x86
				\item Uses register for input as well as access values from memory.
				\item ADD function contains 3 operator.
					\begin{enumerate}
						\item \textbf{Rd} Destination Register
						\item \textbf{Rs} Source Register
						\item \textbf{mem\_address} Address of value to add from memory
					\end{enumerate}
			\end{itemize}

		\subsubsection{Register-Register Architecture}
			\begin{itemize}
				\item Operands from register.
				\item LOAD and STORE only way to access memory.
				\item Need to specify destination register for output.
				\item ADD function has 3 operators.
					\begin{enumerate}
						\item \textbf{Rd} Destination Register
						\item \textbf{Rs} Source Register 
						\item \textbf{Rt} Register containing other value you want to add
					\end{enumerate}
			\end{itemize}

		\subsubsection{Examples}
			Example is $A(1000) + B(2000) = C(3000)$ in the 4 types of architectures
			
			\paragraph{\tab Stack Based Architecture\\}
					PUSH 1000 \\ \tab
					PUSH 2000 \\ \tab
					ADD \\ \tab
					POP 3000

			\paragraph{\tab Accumulator Based\\}
					LOAD 1000 \\ \tab
					ADD 2000 \\ \tab
					STORE 3000

			\paragraph{\tab Register Memory\\}
					LOAD R2, 1000 \\ \tab
					ADD R1, R2, 2000 \\ \tab
					STORE R1, 3000

			\paragraph{\tab Register Register\\}
					LOAD R2, 1000 \\ \tab
					LOAD R3, 2000 \\ \tab
					ADD R1, R2, R3 \\ \tab
					STORE R1, 3000


	\subsection{ISA Classes}
		\paragraph{Classification} generally based on: Instruction word size, number of different instructions, and number of clock cycles to complete a given instruction.

		\subsubsection{Classes}
			\paragraph{RISC} (Reduced Instruction Set Computers) is where size of all instruction words are the same. May lead to simpler decoding hardware. 
			\\ \tab \textbf{MIPS} is an example processor that uses this type of ISA.

			\paragraph{CISC} (Complex Instruction Set Computers) are when the size of instruction words may vary. This is more complex than RISC but code footprint may become smaller due to condensing multiple RISC instructions into one CISC instruction. 
			\\ \tab \textbf{Intel x86} is an example of processors based off this.

			\paragraph{EPIC} (Explicitly Parallel Instruction Computers) include parallel operations in their instruction set. The compiler is very important in EPIC architectures.
			\\ \tab \textbf{Intel Itanium} uses this kind of ISA.

		\subsubsection{Abstractions}
			\paragraph{Abstractions} remove unnecessary details and hide complexity so that it is easier to understand. 

			\paragraph{\tab Instruction Processing in CPU}
			\begin{enumerate}
				\item \textbf{Fetching} accesses memory to get to next instruction. Gets the correct memory address on the bus, and reads its contents.
				\item \textbf{Decoding} Interprets the bits of the instruction word. Identifies which operation to do and data requied (from memory/registers)
				\item \textbf{Execution} Performs the operation. Uses processor and writes result to register/memory.
			\end{enumerate}

		\subsubsection{Questions to ask when designing ISA}
			\begin{enumerate}
				\item What type of ISA should be used?
				\item What operations are needed?
				\item How data (operands) are provided in instructions?
				\item Instruction and Data word sizes?
			\end{enumerate}

	\subsection{Extras}
		\paragraph{\tab Types of operations}
		\begin{itemize}
			\item \textbf{Arithmetic} Addition, Subtraction, Multiplication, Division
			\item \textbf{Logical} AND, OR, Lshift, Rshift
			\item \textbf{Memory Access} LOAD, STORE
			\item \textbf{Control Transfer} Conditional/Unconditional Branches
			\item \textbf{Special Purpose} will talk later
		\end{itemize}	

		\paragraph{Notes: Shifting} You have to be careful when shifting as if you're dealing with signed integers then you may be messing with the sign bit when trying to multiply/divide	


\section{Lecture 3 \& 4}
	\subsection{ALU Operations}
		\begin{itemize}
			\item Addimmediate uses value, not pointer to register
			\item No Subimmediate as if Addimmediate allows negative numbers then we good.
			\item Destination register always before source register/s
			\item Register 0 is static containing all 0s, and cannot be written to
		\end{itemize}

		\paragraph{Endian-ness}
		\begin{enumerate}
			\item \textbf{Little Endian} Least significant bit at top of memory addresses
			\item \textbf{Big Endian} Most significant bit at the top of memory addresses
		\end{enumerate}

		\paragraph{Sizes of things} in relation to memory size \\ \tab Word=4bytes \\ 
		\tab halfword=2bytes \\ 
		\tab 1byte=byte\\ \\
		This course will use MIPS simlulator on PC called SPIM

		\paragraph{Memory addressing in MIPS} machine is C(r$_x$)
			\\ \tab Where C is contstant which may be used to reserve part of memory. 
			\\ \tab And Rx is the contents of a given register

		\begin{itemize}
			\item lw, sw = Load/Store word
			\item lh, sh = Load/Store half-word
			\item lb, sb = Load/Store byte
			\item \textbf{NOTE: } 	lbu = Load byte unsigned. No need to sbu as it will only store the relevant least significant byte in register
		\end{itemize}


	\subsection{Class exercise}
		addi \$10, \$0, 0x3000 \\
		ori \$12, \$0, 0x8015 \\
		sw \$12, 512(\$10) \\ \\
		\$10 = 0000 3000 \\
		\$12 = 0000 8015 \\
		sw register to put \$10 is 512$_{10}$ + 8015$_{16}$ = 0x00003200 \\\\
		Therefore Big Endian: \tab 00 00 80 15 \\
		And Little Endian: \tab \tab 15 80 00 00

	\subsection{Instruction Encoding Cont.}
		\begin{itemize}
			\item \textbf{Note: } For efficient instruction encoding, we classify different instructions and formats for faster decode.
			\item If 32 registers then need 5bits to encode pointer to relevant register.
			\item Opcode needs 6bits to be represented. Can encode 64 opcodes.
			\item Also need some bits to represent immediate values and offsets.
			\item Program Counter (PC) used to signify where execution has got up to and therefore next instruction to execute.
			
		\end{itemize}

		\subsubsection{R-Type Format}
			\begin{itemize}
				\item 6bit OpCode \tab \tab \tab Operation Instruction
				\item 5bit Register \tab \tab \tab First register operand
				\item 5bit Register \tab \tab \tab Second register operand
				\item 5bit Register \tab \tab \tab Third register operand
				\item 5bit Shift \tab \tab \tab \tab Amount for shift instructions
				\item 6bit Function Code \tab Operation variant.
			\end{itemize}


		\subsubsection{I-Type Format}
			\begin{itemize}
				\item 6bit OpCode
				\item 5bit Destination Register
				\item 5bit Source Register
				\item 16bit Offset/Immediate Value (Depending on instruction)
			\end{itemize}

		\subsubsection{Jumping Memory Addresses.}
			\paragraph{Changing sequence of execution: } is done through use of \textbf{branch} and \textbf{jump} instructions. This is done to let you have if/else and loops.
			\begin{enumerate}
				\item[\textbf{Jump}] Jumps to location in memory (unconditionally) to get next instruction. Like a GOTO. Uses J-Type Format
				\item[\textbf{Branch}] lets you conditionally go to another point in memory, only if the condition is met. Uses I-Type Format
			\end{enumerate}

			\paragraph{\tab Jumping} [6bit OpCode][26bit TargetAddress]\\ Target address must be 32 bit, so to get this 26 bit value to 32 bit you shift the 26 bit number left 2 times, then add the 4 MSB of PC to front of value. This results in final expected 32bit address needed for the jump.

			\paragraph{\tab Branching} [6bit OpCode][5bit Reg1][5bit Reg2][16bit Label]
			\begin{itemize}
				\item Once again, the target address must be 32bit, so have to calculate it using enocded information in instruction.
				\item Conditional Branching is \textbf{PC-relative} meaning that the PC provides current address and the Label provides an offset.
			\end{itemize}






2ND HALF
	beq = branch equal, taking 2 inputs
	bne = branch not equal, taking 2 inputs.

slide20
	Else and Exit are kind of like GOTO (symbolic name) Need dollar sign if doing assembly.

	bne and beq only have 16 extra bits.  Therefore need to get to 32bits again somehow for target address. Need to use PC again. Use 14 bits after shifting the 16bits in bne/beq to left by 2.

	Another example
	target address =
		0100 0400 + 4 (from PC+4) + 400 (from 0x100 * 4 [left shift 2])
		= 0100 0804
	Have to also consider is little/big Endian by looking at the machine code of original instruction. The 16bit offset at the end will let you know.

	Yay another example, so excited
		ATTEMPT
			Start: if pc bne \$10 + 32*100 + 32 Exit
				shift right 3 pc

			Start

			Exit: hi there

		ANSWER
			Need to make a counter, use addi for increment/decrement

			addi \$11, \$0, 100	\tab //Initialise counter as 100
			lw \$8, 0(\$10)	\tab // Load word from R10 into R8
			sra	\$9, \$8, 3	\tab // Shift right arithmetic on that and save in R9
			sw 	\tab //Store contents of R9 back into R10
			addu \$10, \$10, 4
			addi \$11, \$11, -1
			bne \$11, \$0, L1

			OP DES SRC

			OP SRC DEST


Lecture 5 \& 6
	Example: Translate the below code to MIPS
		while(w[i] == x)
			i = i + j

		Given that i = \$3, j = \$4, x = \$5, w(int array) = ]\$6


		ANSWER
		<<SOMETHING MISSING>>
		loop: \#perform loop test
			sll \$10, \$3, 2 \tab \#Shift left 2 == x4
			add \$10, \$6, \$10 \tab \#Get address of w[i]
			lw \$11, 0(\$10) \tab \#\$11 = w[i]
			\#perform w[i] == x
			bne \$11, \$5, exit \tab \#Exit when w[i] != x
			\# i = i + j
			add \$3, \$3, \$4
			j loop

		exit:

	Comparison Instructions
		Used for things like (x < y)
		Will set destination register different value depending on result of comparison
		Will then use bne/beq to check if lessthan or greater than.

		slt Rd, Rs, Rt = signed less than
		sltu Rd, Rs, Rt = unsigned less than
		slti Rd, Rs, Immed  = signed immediate less than
		sltiu Rd, Rs, Immed  = unsigned immediate less than

		No implicit instruction to copy from one register to another. But can use contents of \$0 with the ADD or OR $_{(haha)}$ function to achieve the same effect

		Can create sudo instructions if use same set of instructions a lot (kind of like creating a function/script)

\end{document}
