\documentclass{article} 
\newcommand\tab[1][0.5cm]{\hspace*{#1}}

\title{COMPSYS304 Notes 2017} 
\author{Theodore Oswandi} 

\usepackage[
	lmargin=2.5cm,
	rmargin=5cm,
	tmargin=1cm,
	bmargin=3cm,
	]{geometry}
\usepackage{enumitem}
\setlist{noitemsep}
\usepackage[none]{hyphenat}

\begin{document} \maketitle{} 

\section{Lecture 1 \& 2}
	\subsection{Improvements}
		\begin{itemize}
			\item Semiconductor technology and computer architecture has increased lots in last 50 years
			\item Performance, which has also increased can be measured from standardised benchmarks
			\item Clock rate/frequency has also increased considerably in this time.
		\end{itemize}

	\subsection{Computer Architecture}
		\textbf{\tab ISA:} Boundary between hardware and software\\
		\textbf{\tab Oragnisation:} high level computer design aspects\\
		\textbf{\tab Hardware:} detailed logic and circuit design
		\\ \\
		\textbf{\tab Note:} You want to separate your instruction set from implementation

	\subsection{Memory Organisation}
		\begin{itemize}
			\item See memory as single 1D array
			\item Address is index of this array, points to byte of memory.
			\item Memory Access Time: time to read data to/from memory \\ 
			\item Memory Speed != Processor speed.
			\item Fast memory is very expensive. Heirarchy used to maintain fluid functionality and keep things cheap.
		\end{itemize}

		\paragraph{\tab Processor Registers}
		\begin{itemize}
			\item Smallest and fastest memory for CPU
			\item about 32-64 of them.
			\item Each are 32/64bits in size.
			\item Nanosecond access time
		\end{itemize}

		\paragraph{\tab Cache Memory}
		\begin{itemize}
			\item Slower than register
			\item 8-256k
			\item Few nanoseconds access time
			\item Levels to this as well. L1, L2, L3 cache used in multiprocessor systems.
		\end{itemize}

		\paragraph{\tab Main Memory}
		\begin{itemize}
			\item Slower than cache
			\item Megabytes to gigabytes of size.
			\item Tens of nanoseconds lookup time.
		\end{itemize}

	\subsection{Instruction Set Architecture (ISA)}
		\paragraph{\tab ISA} is interface between hardware and low level software.
		\paragraph{\tab Modern ISA} include 80x86, MIPS, ARM

		\subsubsection{Using Fixed ISAs}
			\paragraph{} Uses old instruction set (1970s), also used with extensions to enable newer technologies such as internet, etc...

			\paragraph{\tab Advantages}
			\begin{itemize}
				\item AMD/Intel both have same ISA but different implementation.
			\end{itemize}

			\paragraph{\tab Disadvantages}
				\begin{itemize}
					\item power consumption is higher than things like iPad which use different ISA and consume a lot less power
					\item Also prevent some new innovation since it is so widely used in today's world.
				\end{itemize}


		\subsubsection{ISA Design}
			\paragraph{\tab Need to ask:}
			\begin{itemize}
				\item What operations do the CPU need to do?
				\item How to provide data for given operations?
				\item How to store results of these calculations?
			\end{itemize}

			\paragraph{\tab Need to define:}
			\begin{itemize}
				\item Instruction Format and Encoding
				\item Data types and their sizes
				\item Location of operands and where to store results
			\end{itemize}

		\paragraph{\tab Operands and Opcodes} To carry out these calculations, an \textbf{opcode} must be defined to define these calculations. Upon these opcodes, zero to three \textbf{operands} are used for data inputs and result outputs.

	\subsection{Architecture Types}
		\subsubsection{Stack Base Architecture}
			\begin{itemize}
				\item Top of stack will contain result of operation.
				\item If receive ADD then processor knows next 2 inputs contain 2 numbers that need to be added.
				\item PUSH add something to top of stack.
				\item POP use value in top of stack.
				\item JVM designed to use Stack based architecture.
				\item ADD function has no operators. Operates on last 2 loaded values.
			\end{itemize}

		\subsubsection{Accumulator Based Archictecture.}
			\begin{itemize}
				\item Using inputs from memory.
				\item Not used anymore today. Used in 1970s
				\item ADD function takes one operator, $mem_address$ which contains the value to add to above loaded value.
			\end{itemize}

		\subsubsection{Register Memory Architecture}
			\begin{itemize}
				\item Currently used today as x86
				\item Uses register for input as well as access values from memory.
				\item ADD function contains 3 operator.
					\begin{enumerate}
						\item \textbf{Rd} Destination Register
						\item \textbf{Rs} Source Register
						\item \textbf{mem\_address} Address of value to add from memory
					\end{enumerate}
			\end{itemize}

		\subsubsection{Register-Register Architecture}
			\begin{itemize}
				\item Operands from register.
				\item LOAD and STORE only way to access memory.
				\item Need to specify destination register for output.
				\item ADD function has 3 operators.
					\begin{enumerate}
						\item \textbf{Rd} Destination Register
						\item \textbf{Rs} Source Register 
						\item \textbf{Rt} Register containing other value you want to add
					\end{enumerate}
			\end{itemize}

		\subsubsection{Examples}
			Example is $A(1000) + B(2000) = C(3000)$ in the 4 types of architectures
			
			\paragraph{\tab Stack Based Architecture\\}
					PUSH 1000 \\ \tab
					PUSH 2000 \\ \tab
					ADD \\ \tab
					POP 3000

			\paragraph{\tab Accumulator Based\\}
					LOAD 1000 \\ \tab
					ADD 2000 \\ \tab
					STORE 3000

			\paragraph{\tab Register Memory\\}
					LOAD R2, 1000 \\ \tab
					ADD R1, R2, 2000 \\ \tab
					STORE R1, 3000

			\paragraph{\tab Register Register\\}
					LOAD R2, 1000 \\ \tab
					LOAD R3, 2000 \\ \tab
					ADD R1, R2, R3 \\ \tab
					STORE R1, 3000


	\subsection{ISA Classes}
		\paragraph{Classification} generally based on: Instruction word size, number of different instructions, and number of clock cycles to complete a given instruction.

		\subsubsection{Classes}
			\paragraph{RISC} (Reduced Instruction Set Computers) is where size of all instruction words are the same. May lead to simpler decoding hardware. 
			\\ \tab \textbf{MIPS} is an example processor that uses this type of ISA.

			\paragraph{CISC} (Complex Instruction Set Computers) are when the size of instruction words may vary. This is more complex than RISC but code footprint may become smaller due to condensing multiple RISC instructions into one CISC instruction. 
			\\ \tab \textbf{Intel x86} is an example of processors based off this.

			\paragraph{EPIC} (Explicitly Parallel Instruction Computers) include parallel operations in their instruction set. The compiler is very important in EPIC architectures.
			\\ \tab \textbf{Intel Itanium} uses this kind of ISA.

		\subsubsection{Abstractions}
			\paragraph{Abstractions} remove unnecessary details and hide complexity so that it is easier to understand. 

			\paragraph{\tab Instruction Processing in CPU}
			\begin{enumerate}
				\item \textbf{Fetching} accesses memory to get to next instruction. Gets the correct memory address on the bus, and reads its contents.
				\item \textbf{Decoding} Interprets the bits of the instruction word. Identifies which operation to do and data requied (from memory/registers)
				\item \textbf{Execution} Performs the operation. Uses processor and writes result to register/memory.
			\end{enumerate}

		\subsubsection{Questions to ask when designing ISA}
			\begin{enumerate}
				\item What type of ISA should be used?
				\item What operations are needed?
				\item How data (operands) are provided in instructions?
				\item Instruction and Data word sizes?
			\end{enumerate}

	\subsection{Extras}
		\paragraph{\tab Types of operations}
		\begin{itemize}
			\item \textbf{Arithmetic} Addition, Subtraction, Multiplication, Division
			\item \textbf{Logical} AND, OR, Lshift, Rshift
			\item \textbf{Memory Access} LOAD, STORE
			\item \textbf{Control Transfer} Conditional/Unconditional Branches
			\item \textbf{Special Purpose} will talk later
		\end{itemize}	

		\paragraph{Notes: Shifting} You have to be careful when shifting as if you're dealing with signed integers then you may be messing with the sign bit when trying to multiply/divide	


\section{Lecture 3 \& 4}
	\subsection{ALU Operations}
		\begin{itemize}
			\item Addimmediate uses value, not pointer to register
			\item No Subimmediate as if Addimmediate allows negative numbers then we good.
			\item Destination register always before source register/s
			\item Register 0 is static containing all 0s, and cannot be written to
		\end{itemize}

		\paragraph{Endian-ness}
		\begin{enumerate}
			\item \textbf{Little Endian} Least significant bit at top of memory addresses
			\item \textbf{Big Endian} Most significant bit at the top of memory addresses
		\end{enumerate}

		\paragraph{Sizes of things} in relation to memory size \\ \tab Word=4bytes \\ 
		\tab halfword=2bytes \\ 
		\tab 1byte=byte\\ \\
		This course will use MIPS simlulator on PC called SPIM

		\paragraph{Memory addressing in MIPS} machine is C(r$_x$)
			\\ \tab Where C is contstant which may be used to reserve part of memory. 
			\\ \tab And Rx is the contents of a given register

		\begin{itemize}
			\item lw, sw = Load/Store word
			\item lh, sh = Load/Store half-word
			\item lb, sb = Load/Store byte
			\item \textbf{NOTE: } 	lbu = Load byte unsigned. No need to sbu as it will only store the relevant least significant byte in register
		\end{itemize}


	\subsection{Class exercise}
		addi \$10, \$0, 0x3000 \\
		ori \$12, \$0, 0x8015 \\
		sw \$12, 512(\$10) \\ \\
		\$10 = 0000 3000 \\
		\$12 = 0000 8015 \\
		sw register to put \$10 is 512$_{10}$ + 8015$_{16}$ = 0x00003200 \\\\
		Therefore Big Endian: \tab 00 00 80 15 \\
		And Little Endian: \tab \tab 15 80 00 00

	\subsection{Instruction Encoding Cont.}
		\begin{itemize}
			\item \textbf{Note: } For efficient instruction encoding, we classify different instructions and formats for faster decode.
			\item If 32 registers then need 5bits to encode pointer to relevant register.
			\item Opcode needs 6bits to be represented. Can encode 64 opcodes.
			\item Also need some bits to represent immediate values and offsets.
			\item Program Counter (PC) used to signify where execution has got up to and therefore next instruction to execute.
			
		\end{itemize}

		\subsubsection{R-Type Format}
			\begin{itemize}
				\item 6bit OpCode \tab \tab \tab Operation Instruction
				\item 5bit Register \tab \tab \tab First register operand
				\item 5bit Register \tab \tab \tab Second register operand
				\item 5bit Register \tab \tab \tab Third register operand
				\item 5bit Shift \tab \tab \tab \tab Amount for shift instructions
				\item 6bit Function Code \tab Operation variant.
			\end{itemize}


		\subsubsection{I-Type Format}
			\begin{itemize}
				\item 6bit OpCode
				\item 5bit Destination Register
				\item 5bit Source Register
				\item 16bit Offset/Immediate Value (Depending on instruction)
			\end{itemize}

		\subsubsection{Jumping Memory Addresses.}
			\paragraph{Changing sequence of execution: } is done through use of \textbf{branch} and \textbf{jump} instructions. This is done to let you have if/else and loops.
			\begin{enumerate}
				\item[\textbf{Jump}] Jumps to location in memory (unconditionally) to get next instruction. Like a GOTO. Uses J-Type Format
				\item[\textbf{Branch}] lets you conditionally go to another point in memory, only if the condition is met. Uses I-Type Format
			\end{enumerate}

			\paragraph{\tab Jumping} [6bit OpCode][26bit TargetAddress]\\ Target address must be 32 bit, so to get this 26 bit value to 32 bit you shift the 26 bit number left 2 times, then add the 4 MSB of PC to front of value. This results in final expected 32bit address needed for the jump.

			\paragraph{\tab Branching} [6bit OpCode][5bit Reg1][5bit Reg2][16bit Label]
			\begin{itemize}
				\item Once again, the target address must be 32bit, so have to calculate it using enocded information in instruction.
				\item Conditional Branching is \textbf{PC-relative} meaning that the PC provides current address and the Label provides an offset.
			\end{itemize}






2ND HALF
	beq = branch equal, taking 2 inputs
	bne = branch not equal, taking 2 inputs.

slide20
	Else and Exit are kind of like GOTO (symbolic name) Need dollar sign if doing assembly.

	bne and beq only have 16 extra bits.  Therefore need to get to 32bits again somehow for target address. Need to use PC again. Use 14 bits after shifting the 16bits in bne/beq to left by 2.

	Another example
	target address =
		0100 0400 + 4 (from PC+4) + 400 (from 0x100 * 4 [left shift 2])
		= 0100 0804
	Have to also consider is little/big Endian by looking at the machine code of original instruction. The 16bit offset at the end will let you know.

	Yay another example, so excited
		ATTEMPT
			Start: if pc bne \$10 + 32*100 + 32 Exit
				shift right 3 pc

			Start

			Exit: hi there

		ANSWER
			Need to make a counter, use addi for increment/decrement

			addi \$11, \$0, 100	\tab //Initialise counter as 100
			lw \$8, 0(\$10)	\tab // Load word from R10 into R8
			sra	\$9, \$8, 3	\tab // Shift right arithmetic on that and save in R9
			sw 	\tab //Store contents of R9 back into R10
			addu \$10, \$10, 4
			addi \$11, \$11, -1
			bne \$11, \$0, L1

			OP DES SRC

			OP SRC DEST


Lecture 5 \& 6
	Example: Translate the below code to MIPS
		while(w[i] == x)
			i = i + j

		Given that i = \$3, j = \$4, x = \$5, w(int array) = ]\$6


		ANSWER
		<<SOMETHING MISSING>>
		loop: \#perform loop test
			sll \$10, \$3, 2 \tab \#Shift left 2 == x4
			add \$10, \$6, \$10 \tab \#Get address of w[i]
			lw \$11, 0(\$10) \tab \#\$11 = w[i]
			\#perform w[i] == x
			bne \$11, \$5, exit \tab \#Exit when w[i] != x
			\# i = i + j
			add \$3, \$3, \$4
			j loop

		exit:

	Comparison Instructions
		Used for things like (x < y)
		Will set destination register different value depending on result of comparison
		Will then use bne/beq to check if lessthan or greater than.

		slt Rd, Rs, Rt = signed less than
		sltu Rd, Rs, Rt = unsigned less than
		slti Rd, Rs, Immed  = signed immediate less than
		sltiu Rd, Rs, Immed  = unsigned immediate less than

		No implicit instruction to copy from one register to another. But can use contents of \$0 with the ADD or OR $_{(haha)}$ function to achieve the same effect

		Can create sudo instructions if use same set of instructions a lot (kind of like creating a function/script)


	SECOND HALF OF LECTURES GO HERE, RAN OUT OF LAPTOP BATTERY

LEctures 7 \& 8
	Knowledge for assignent should be taught by next tuesday

	Stackframes
		in MIPS have predetermined allocated area
		areas of stackframe
			Local and Temp variables
			Saved Register (+ return reg)
			argument build
		It will try to use registers if possible, but if memory requirements too high then will use stack frame
		Size of stack frame should be multiple of 16

	Memory layout
		kernel bit
			top up to 0x7ffffffffffffffffffffffffffffffff
		text segment
			program instruction program
			lower bit reserved for OS special task
		data segment
			objects with known size
			above text segment growing up

		stack segment
			stack starting from 0x7ffffffffff growing down

		Problem 
			If have nested functions then \$31 contents will be overwritten. Therefore you save the value of \$31 when you call more functions in the stack frame
			Use offset of 16 to store these values in the stackframe

	Example
		Translate below to MIPS

		main(){
			int a, b, c, d, e, f, z;
			a = 10; b = -12; c = 120; d = 18; e = -2; f = 23;
			z = func1(a,b,c,d,e,f);
		}

		int func1(int x1, x2, x3, x4, x5, x6){
			int result;
			result = x1 + x2 - x3 + x4 + x5 + x6;
			return result;
		}

	Summary of stack frame usage
		SUMMARY HERE

Lecture 8
	MIPS assembly programming
		main CPU with ALU and special registers for mult/div
		Coprocessor for floating point stuff
		Coprocessor for traps and memory

		Assembly directives
			identifiers are used to provide commands to assembler.
			prefaced with a dot (.)

Lecture 9
	MISSED IT

Lecture 10 (From slides 20/29 onwards)
	Can't just add a float to an int
	mtcZ/mfcZ is move to/from coprocessor. Z value = 1 represents co-processor for floating point
		This function just moves the bits to/from the registers and doesn't do the conversion

	cvt = convert instruction
	.d.s = single precision convert to double precision
	.d.w = integer convert to double precision

	Class example
		Do Z = 8*X + Y

	Another example
		Check how many values in array are -Infinity

		-Infinity cannot be represented so have to check contents of register to see if it contains proper value

Lecture 11 \& 12
	(2)Digital Circuit are classified as combinational or sequential circuits
		Combinational	output only dependent on current input value
		Sequential 	output dependent on current input and state

	(3) propagation delay exists
	(4) charge/discharge of load capacitance results in nonzero propagation delay
	(5) this nonzero prop delay may cause 'glitches' in the expcted output of the circuit
		Not concerned with details, but can't assume ideal case in the real world. Therefore should take prop delay into account at all times
	(6) Sequential circuits
		have some kind of storage element to keep current state of program
		clock to synch state transition
	(7,8) With flipflops, remember that it also has delays
		setuptime = minimum stable time for D input signal before change in CLK
		hold time = minimum time D has to be stable after CLK edge

		FlipFlop = edge triggered. changes only occur when CLK positive or negative edge rise/fall
		Latch = level sensitive. changes only occur when CLK either 0 or 1

	(9) IMPLEMENTATION AND ORGANISATION

	(10) CPU implementation
		Control Unit
			Generate signals to direct datapath
		Datapath
			perform CPU operations

		ALU performs on registers
			Has special extra outputs to show extra information about result given. Zero and Overflow
			Overflow for result that overflows 32bit
			Zero signifies the result being 0 or not

			Needs 3 bits to say what operation to do
			SLT = Less than, can be performed by using subtract in ALU


		Register File
			R type instruction need to take in 2 register values and return to specified register
			Uses to represent which registers need to be read and written to

			Not using register read signal, but keep in mind for real world.

		Program Counter PC
			Indicate address of next instruction to be executed
			Also have signals for reading or writing

		Memory Interfacing
			used to access memory for instruction
			can add read signal if needed

		Sign Extension
			Converts the 16 immediate value to the 32bit value needed needed for instructions. Also keeps the sign bit if needed (NOT SURE)

	ISA subsert implementation
		Single cycle impelementation
			Assume single clock cycle long enough to accommodate the delays. This is the edges
			Therefore assume everything can be done in a single clock cycle

			Duty cycle
				percentage of highs compared to lows (NOT SURE)

		Fetch --> Decode --> Execute

		Fetch
			Need the PC to get the address of instruction needed to carry out
			Instruction Momory to get instruction word
			Also need something to increment PC by 4, to be ready for the next instruction to be executed

		R-Type Instructions
			need to get values from registers, so need Register File
			Need the ALU to perform some kind of operation on vlaues of these registers 
			Need Register File to specify the output register for opertaion too

		Load/Store
			If doing Load/Store then result of ALU needs to be fed into a Memory Intefacing which will then output to the Register File for destination register

		Immediate Values into ALU
			get this value straight from register (not though Register File) and ensure that it goes through a Sign Extender first
			This is due to instruction needing the 32bit value to perform operation on, and the 16bit input needing to be converted to 32bit.


	Example
		Impelementing BEQ
			Need to use ALU and Subtract, check the output Zero bit to see if values in registers are the smae
			Also need to generate the target address from the 16 bit value of immediate/offset from original instruction
				Use PC+4 and ALU. But cannot use ALU again since trying to do this all in the same clock cycle

			If ALU(z) is true
				generate new PC value, equality check successful
			else
				use whatever PC currently contains, as equality check unsuccessful

	Datapath and Control Unit

		ALU used for [add, sub, and, or, lw, sw, beq]
		add - to calculate m]emory address
		sub - for beq
		ALUop[0,1] generated by main control unit, used for opcode conversion/translation for actual ALU operation input

	Control Signal for ALU
			ALUop	
		lw	00
		sw	00
		beq	01
		
Lecture 13
	Single Cycle Datapath Impelementation cont.
		(11) not correct as inputs for read/write registers for src/dest of some operatiions not guaranteed. Some have OP rs rd and some have OP rd rs

		(12) Sequential circuits need to have clock inputs, not shown in the diagram.

		(14) have another section used for generating and allocating the various control signals
		- easiest way to set these control signals is to just generate a table to map 1/0 values to the various outputs needed for each opcode

		Control Unit
			Input = 6bit Opcode
			Output = various control signals for sections of datapath

			Outputs:
				RegDst
				ALUsrc
				MemtoReg
				RegWrite
				MemRead
				MemWrite
				branch
				ALUop1
				ALUop0

			This control section is combinational since it just takes the opcode and assert values on the output control signals without need of clock

		Implementing Jump Instruction
			Jump insturctions doesn't use registers
			Since it changes PC unconditionally, only datapath section that relates to PC needs to be extended. 
			Need to create new control signal to gate either jump or branch instruction

		(20) can't execute archive instructions on given datapath 

		Implement BNE Instruction
			Can still use the sub with ALU and zero bit
			Also can use the register loading from BEQ
			Need to create new control signal to distinguish BNE and BEQ
				Same as BEQ, but you negate the zero value
			Then OR the result  of both the BEQ and BNE AND gates

		Implementing addi
			Can modify ALU control
			Or can also choose not to modify ALU at all and change how the registers are loaded, however this is harder to do


		Example, list values of control signals for:   
			ori \$10, \$11, 0x101A

			RegDst		0	Not reading from third register
			Jump		0	Not jump
			Branch\_ne	0	Not Branch
			Branch\_eq	0	Not Branch
			Memread		0	Don't read memory
			MemtoReg	0	Using value of address
			ALUop		11	Use value for immediate value (no table given)
			Memwrite	0
			ALUsrc		1
			Regwrite	1

	Improving Performance
		In reality these components have delays associated with them
		Memory Unit = 2ns
		ALU \& Adder = 2ns
		Register File (R/W) = 1ns
		Others = assumed to be negligible

		6ns for archive instruction (R-type)
			2ns for getting from memory
			1ns for reading from register
			2ns for ALU adding
			1ns for writing to register

		LW instruction
			DIDN"T GET IT

		Example 2
			Timing
				SInce single cycle implementation then get the highest delay as the total delay per cycle. No need to add all delays

		Performance Single Cycle Implementation
			Comparing:
			\begin{enumerate}
				\item single-cycle impelmentation with pessimistic clock timing due to longest instruction
				\item Single cycle implementation where each clock cycle only runs for as long as it needs to. Not possible in real life, but just for conceptual purposes
			\end{enumerate}

			IC = Instruction Count

		Multicycle implementation
		\begin{itemize}
			\item Uses multiple clock cycles of clock that runs faster than doing everything on one long clock cycle
			\item Different clock cycles used for each of the different phases of execution of an instruction
			\item control units have to become more complex
			\item however datapath may become more simpler
		\end{itemize}

		\begin{itemize}
			\item has shared memory unit and ALU
			\item don't need to separate instruction and memory fetch since can be done in multiple cycles like in single cycle
			\item Single memory interface enough for this implementation
		\end{itemize}

			Goal: to separate it to allow for multiple cycles for a single instruction

Lecture 15 \& 16
	Multicycle implementation of MIPS ISA
		\begin{itemize}
			\item Mutltiple clock cycle for single full instruction
			\item Some functional units not used in some clock cycles, can share between instructions
			\item Need to store state between these cycles. So will need some temporary registers
			\item Simpler data path, but more complex control unit as a result
		\end{itemize}

	High elvel view
		ALUout are temporary register to keep value of ALU computed in a clock cycle
		IR write, Memory Data, RegisterReadA, RegisterReadB, and ALUout are temporary registers
		
		Problem - to figure out how many clock cycles to allocate to each of the different types of instructions.

		3 different sections 
		\begin{enumerate}
			\item Get from memory section
			\item Register Section
			\item ALU section
		\end{enumerate}

		Some 4 clock cycle instructions
		\begin{enumerate}
			\item Get from memory
			\item Load registers
			\item Calculate result
			\item Store result back to memory
		\end{enumerate}

		R type
		\begin{itemize}
			\item Instruction Fetch
			\item Decode/Register Fetch
			\item Execution
			\item Memory Access, finish R-type, write ALUout to register values
		\end{itemize}

		Memory Reference
		\begin{itemize}
			\item Instruction Fetch
			\item Decode/Register Fetch
			\item Execution
			\item Memory Access, either LOAD or STORE
			\begin{itemize}
				\item If load, then need to finish memory read
			\end{itemize}
		\end{itemize}

		Branch Instructions
		\begin{itemize}
			\item Instruction Fetch
			\item Decode/Register Fetch
			\item Execution, and update PC to ALUout
		\end{itemize}

		Jump Instructions
		\begin{itemize}
			\item Instruction Fetch
			\item Decode/Register Fetch
			\item Execution, and update PC to register values
		\end{itemize}

		IorD = used to signify when you want to use PC as location of memory address when set to 0

		For a given set of signals that need to be asserted, make sure that other signals won't affect the intended result of the asserted signals

		TODO
		Explanation of Control Unit Signals
		\begin{itemize}
			\item Outputs Control
			\begin{enumerate}
				\item PCWriteCond
				\item PCWrite
				\item IorD
				\item MemRead
				\item MemWrite
				\item MemtoReg
				\item IRWrite
				\item PCSource
				\item ALUOp
				\item ALUSrcB
				\item ALUSrcA
				\item RegWrite
				\item RegDst
			\end{enumerate}
		\end{itemize}
		
	Also need to calculate average cycles per instruction

	Loading takes highest number of cycles, therefore reducing this should make overall performance faster if doing multiple cycle datapath

	Exaple with machines with different characteristics
		Look at overall FSM and combine states that are in description of machines, as they are performed on the same clock cycle
		Then look at critical path of number of cycles and determine the machine with best overall performance 

	Performance depends on both clock period and average instructions per instruction so need to find best balance between the two.



\end{document}
