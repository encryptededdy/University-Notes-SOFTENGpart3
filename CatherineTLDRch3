CatherineTLDRch3
Chapter 3 - Transport Layer
	3.1 - Transport Layer Services
		General
			- Provides logical communication between app processes on different hosts
			- transport protocol run on end system
			- breakup sending app msg, remake received app msgs

		Network & Transport layer
			NETWORK: logical communcation between hosts
			TRANSPORT: logical communication between processes

		Protocols
			TCP: reliable with congestion/flow control
			UDP: unreliable but fast

			- Neither guarantee delays or bandwidth

	3.2 - Multiplexing and Demultiplexing
		MULTIPLEXING
			- done at sender
			- handle data from multiple sockets
			- add transport header

		DEMULTIPLEXING
			- done at receiver
			- send received packet to right socket

			Datagram
				- source & dest IP 
				- source & dest port#
			Host uses IPaddress + Port# to send segment to right socket

		Connectionless Demultiplexing (UDP)
			- when get UDP segment check port# and send segment to relevant socket

			IPdatagram wth same dest&port# but different sourceIP/sourcePort# will be put in same socket at dest

		Connection Oriented Demultiplexing (TCP)
			4-tuple ID for TCP socket
			- Source IP
			- Source Port#
			- Dest IP
			- Dest Port#

			- Demultiplexing uses all 4 values to find correct socket
			- host may have multiple TCP connections and therefore IDed by the 4tuple
			- Web servers handle differently, have different socket for each connecting client

			All destined to IPaddr B on same port have different socket if different src
			
	3.3 - Connectionless Transport (UDP)
		General
			Packets sent to receiver and hope it gets there. No handshaking
			- Packets can get lost and received out of order
			- can add reliability in application layer

			Uses
			- Multimedia Streaming (loss tolerant, time sensitive)
			- DNS
			- SNMP Simple Network Management

		Segments
			- small header (8bit, TCP=20bit)

			Structure 32bit wide
			| source | dest port# |
			| length | checksum   |
			| payload             |

			Checksum
				- used to detect errors
				- sender treats segment as list of 16bit numbers and sums
				- receiver computers segment contents and check with checksum
				- if has 1 in extra digit then add 1 to sum

	3.4 - Principles of Reliable data transfer

	3.5 - Connection Oriented Transport (TCP)
		General
			- one sender one receiver
			- reliable, in order
			- pipelined (flow and congestion control)
			- need handshaking
			- sender can't overwhelm receiver
			- bidirection data flow using max segment size

		3.5.1 - Segment Structure 32bit wide
			| src port		| dest port		|
			| sequence number				|
			| ACK number					|
			| BunchOfFlags	| receive window|
			| checksum		|				|
			| options						|
			| payload						|

			ACKs
			- used to signify sequence# of next byte. Used to reorder at later time
			- used to let them know that they got packet, ACK will echo message X back

			Timeout & RTT
				- TCP RTT > RTT
				- don't want premature timeout so don't make too short
				- don't want slow reaction so don't make too long

				- Uses old values of SampleRTT to calculate expectedRTT of newer packet

				[FORMULA GO HERE]

				TImeout interval calculated with expectedRTT + some deviation just in case

		3.5.2 - Reliable Data Transfer
			TCP creates layer of reliability over IP's unreliable nature
			- pipeline segments
			- use of ACKs
			- single transmission timer

			Retransmissions if something suspected to be lost
			- timeouts
			- duplicate ACKs

			As sender:
				1	break up data into segments
				2	create segment with seq#
				3	send it & start timer
				4	IF TIMEOUT
						resend & restart timer
					ELSE ACKed
						update known ACKs
						send new seq and restart timer

			TCP ACK generation (at receiver)

				EVENT: get out of order ACK
				ACTION: Delay ACK, wait and if older one doesn't come send ACK

				EVENT: get in order segment, with another segment ACK pending
				ACTION: immediately send cumulativeACK

				EVENT: get out of order segment at higher seq#
				ACTION: send duplcicateACK

				EVENT: get segment that fills gap created above
				ACTION: send ACK

			TCP Fast Retransmit
				- Sometimes timeout times for segments too long and therefore take to long to send data
				- Instead send multiple packets and see what ACKs you get.
				- If multiple ACKs with same seq# then know something was probably lost.

				- Will receive multiple ACK with seq# of first unreceived segment

		3.5.3 - Flow Control
			- Try match rate of sender with what receiver can accept

			- Receiver advertises free buffer. RWND in header
			- Therefore sender accomodates how much they send by the RWND value
			- Ensure no overflow

		3.5.4 - Connection Management
			- Have to first handshake the 2 hosts before data transfer
			- Agree on connection parameters

			Usual
				1	A send SYN to B
				2	B ACK A, connection established

			3-Way-Handshake
				1	A send SYN to B
				2	B send SYNACK to A
				3	A send final ACK to B, connection established

				A chooses num X for initial SYN
				B choosed num Y, send that and X+1 in SYNACK
				A send Y+1 in final ACK

			Closing Connection
				Once done, both client and server finish with FIN=1. Still has to be ACKed (usually with other FIN=1)

				Similar to 3wayhandshake with the X, X+1, Y and Y+1

	3.6 - Principles of Congestion Control
		General
			- Network should be able to handle amount of information sent, if not measures should be in place to ensure this is the case
			- Not same as flow control

		Scenarios

			Upper limit of OUT is R/2 with linear relationship with IN

			1	With infinite buffer can easily just send what you want and it will get there after delay

			2	With finite buffer then there is chance of lost packet

			Ideal: just resend packet if lost. But requires perfect knowledge of whole system to identify which ones.

			Therefore copy of data kept in transport layer so can retransmit if lost. Only resent if known to be lost.

			Realistic: Duplicates occur due to premature timeout. This is waste of processing power

			3	Four senders, with multihop paths.
				Basically if one connection from AtB saturates a router then others trying to use routes will have chance of packets being dropped.

			This is another cost of congestion

		Posible Approaches
			End-End Control
				- no network feedback
				- uses TCP and dupACK to learn when network congested

			Network Assisted Control
				- router provide information to end systems.
				- Uses bit flags to signify.

	3.7 - TCP congestion control